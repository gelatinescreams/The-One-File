<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }	  
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;	
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }   
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	
	
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
   
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>     
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765239449323" fill="none" marker-end="url(#arrow-forward)" points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" data-edge-id="custom-1765239449323" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2103.968290880771,268)" style="cursor: grab;"><circle r="252" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="201.6" height="201.6" x="-100.8" y="-100.8" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"><path d="M144.3 214.1c0 6.3.7 11.4 1.9 15.2 1.4 3.7 3.1 7.8 5.4 12.3.9 1.4 1.2 2.7 1.2 3.9 0 1.7-1 3.4-3.2 5.1l-10.7 7.2c-1.5 1-3.1 1.5-4.4 1.5-1.7 0-3.4-.9-5.1-2.4-2.4-2.6-4.4-5.3-6.1-8-1.7-2.9-3.4-6.1-5.3-10-13.3 15.7-30 23.5-50.1 23.5-14.3 0-25.7-4.1-34.1-12.3-8.3-8.2-12.6-19.1-12.6-32.7 0-14.5 5.1-26.2 15.5-35.1S60.8 169 78.4 169c5.8 0 11.7.5 18.1 1.4s12.8 2.2 19.6 3.7v-12.4c0-12.9-2.7-22-8-27.2-5.4-5.3-14.6-7.8-27.8-7.8-6 0-12.1.7-18.4 2.2s-12.4 3.4-18.4 5.8c-2.7 1.2-4.8 1.9-6 2.2s-2 .5-2.7.5c-2.4 0-3.6-1.7-3.6-5.3v-8.3c0-2.7.3-4.8 1.2-6s2.4-2.4 4.8-3.6c6-3.1 13.1-5.6 21.5-7.7 8.3-2.2 17.2-3.2 26.6-3.2 20.3 0 35.1 4.6 44.6 13.8 9.4 9.2 14.1 23.2 14.1 41.9v55.2zM75.2 240c5.6 0 11.4-1 17.5-3.1 6.1-2 11.6-5.8 16.2-10.9 2.7-3.2 4.8-6.8 5.8-10.9s1.7-9 1.7-14.8v-7.2c-4.9-1.2-10.2-2.2-15.7-2.9-5.4-.7-10.7-1-16-1-11.4 0-19.8 2.2-25.4 6.8S51 207.1 51 215.6c0 8 2 14 6.3 18.1 4.1 4.2 10 6.3 17.9 6.3m136.7 18.4c-3.1 0-5.1-.5-6.5-1.7-1.4-1-2.6-3.4-3.6-6.6l-40-131.6c-1-3.4-1.5-5.6-1.5-6.8 0-2.7 1.4-4.3 4.1-4.3h16.7c3.2 0 5.4.5 6.6 1.7 1.4 1 2.4 3.4 3.4 6.6l28.6 112.7 26.6-112.7c.9-3.4 1.9-5.6 3.2-6.6 1.4-1 3.7-1.7 6.8-1.7H270c3.2 0 5.4.5 6.8 1.7 1.4 1 2.6 3.4 3.2 6.6l26.9 114.1 29.5-114.1c1-3.4 2.2-5.6 3.4-6.6 1.4-1 3.6-1.7 6.6-1.7h15.8c2.7 0 4.3 1.4 4.3 4.3 0 .9-.2 1.7-.3 2.7-.2 1-.5 2.4-1.2 4.3l-41 131.6q-1.5 5.1-3.6 6.6c-1.4 1-3.6 1.7-6.5 1.7h-14.6c-3.2 0-5.4-.5-6.8-1.7s-2.6-3.4-3.2-6.8l-26.4-109.8L236.7 250c-.9 3.4-1.9 5.6-3.2 6.8-1.4 1.2-3.7 1.7-6.8 1.7zm218.8 4.6c-8.9 0-17.7-1-26.2-3.1-8.5-2-15.2-4.3-19.6-6.8-2.7-1.5-4.6-3.2-5.3-4.8s-1-3.2-1-4.8v-8.7c0-3.6 1.4-5.3 3.9-5.3 1 0 2 .2 3.1.5 1 .3 2.6 1 4.3 1.7 5.8 2.6 12.1 4.6 18.7 6 6.8 1.4 13.5 2 20.3 2 10.7 0 19.1-1.9 24.9-5.6s8.9-9.2 8.9-16.2c0-4.8-1.5-8.7-4.6-11.9s-8.9-6.1-17.2-8.9l-24.7-7.7c-12.4-3.9-21.6-9.7-27.2-17.4-5.6-7.5-8.5-15.8-8.5-24.7 0-7.2 1.5-13.5 4.6-18.9s7.2-10.2 12.3-14c5.1-3.9 10.9-6.8 17.7-8.9 6.8-2 14-2.9 21.5-2.9 3.7 0 7.7.2 11.4.7 3.9.5 7.5 1.2 11.1 1.9 3.4.9 6.6 1.7 9.7 2.7s5.4 2 7.2 3.1c2.4 1.4 4.1 2.7 5.1 4.3 1 1.4 1.5 3.2 1.5 5.6v8c0 3.6-1.4 5.4-3.9 5.4-1.4 0-3.6-.7-6.5-2q-14.55-6.6-32.7-6.6c-9.7 0-17.4 1.5-22.6 4.8s-8 8.2-8 15.2c0 4.8 1.7 8.9 5.1 12.1s9.7 6.5 18.7 9.4l24.2 7.7c12.3 3.9 21.1 9.4 26.4 16.3s7.8 15 7.8 23.8c0 7.3-1.5 14-4.4 19.8-3.1 5.8-7.2 10.9-12.4 15-5.3 4.3-11.6 7.3-18.9 9.5-8 2.5-16 3.7-24.7 3.7" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path><path d="M462.9 345.7c-56 41.4-137.4 63.3-207.4 63.3-98.1 0-186.5-36.3-253.2-96.6-5.3-4.8-.5-11.2 5.8-7.5 72.2 41.9 161.3 67.3 253.4 67.3 62.2 0 130.4-12.9 193.3-39.5 9.3-4.2 17.3 6.2 8.1 13m23.3-26.5c-7.2-9.2-47.3-4.4-65.6-2.2-5.4.7-6.3-4.1-1.4-7.7 32-22.5 84.6-16 90.8-8.5 6.1 7.7-1.7 60.3-31.7 85.5-4.6 3.9-9 1.9-7-3.2 6.9-16.9 22.1-54.9 14.9-63.9" style="fill-rule: evenodd; clip-rule: evenodd; fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-47.040000000000006" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="67.2" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M512 160.2V400H400V112H112V0h240.4zM112 112H0v240.4L160.2 512H400V400H112z" style="fill:#de3c07"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1773.8400660428597,666.5758233298659)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M462.2 512H49.8C22.3 512 0 489.7 0 462.2V49.8C0 22.3 22.3 0 49.8 0h412.4C489.7 0 512 22.3 512 49.8v412.4c0 27.5-22.3 49.8-49.8 49.8" style="fill:#2e2f33"></path><path d="M108.2 63.9h140.9c97.2 0 154.6 30.4 154.6 129.5v3.4c0 99.4-57.2 129.5-154.5 129.5h-30.7V447H108.2zm134.5 177.8c30.1 0 46-11.2 46-44.6v-3.9c0-33.2-15.8-44.6-46-44.6h-24.2v93.1zM313 358h90.3v90.1H313z" style="fill:#f7f6f3"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1931.1978950081452,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M438.6 0H73.4C33.1 0 .3 32.8.3 73.1v365.7c0 40.3 32.8 73.1 73.1 73.1h365.3c40.3 0 73.1-32.8 73.1-73.1V73.1C511.7 32.8 478.9 0 438.6 0" style="fill-rule:evenodd;clip-rule:evenodd;fill:#8b3bd0"></path><path d="M356.8 53.6v261.3c0 39.3-13.9 72.8-41.8 100.7s-61.4 41.8-100.7 41.8l-23.8-95h23.8c13 0 24.1-4.6 33.2-13.8 9.5-9.5 14.3-20.7 14.3-33.7V148.6H157.3v-95z" style="fill:#fff"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M0 0h512v512H0z" style="fill:#111827"></path><path d="M170.7 85.3 369.8 256 170.7 426.7z" style="fill:#f59e0b"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2342.2663764534577,631.7681967180296)" style="cursor: grab;"><circle r="123" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="98.39999999999999" height="98.39999999999999" x="-49.199999999999996" y="-49.199999999999996"><path d="M501.4 212.3c-11.5-8-38-11-58.6-7-2.4-20-13.5-37.5-32.7-53l-11-8-7.7 11.5c-9.6 15-14.4 36-13 56 .5 7 2.9 19.5 10.1 30.5-6.7 4-20.7 9-38.9 9H2.3l-1 4c-3.4 20-3.4 82.5 36 130.5 29.8 36.5 74 55 132.1 55 125.9 0 219.1-60.5 262.8-170 17.3.5 54.3 0 73-37.5.5-1 1.4-3 4.8-10.5l1.9-4zM280 71.3h-52.8v50H280zm0 60h-52.8v50H280zm-62.5 0h-52.8v50h52.8zm-62.4 0h-52.8v50h52.8zm-62.5 60H39.8v50h52.8zm62.5 0h-52.8v50h52.8zm62.4 0h-52.8v50h52.8zm62.5 0h-52.8v50H280zm62.4 0h-52.8v50h52.8z" style="fill:#2396ed"></path></svg></g><text class="node-label" x="0" y="-22.96" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="32.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M503.1 465.4v2.1c-6 25.5-28.4 44.5-55 44.5H7.3v-46.6h38.3v7.3h403c1.1 0 2 0 2.9-.1 1.8-.1 3.6-.6 5.2-1.3 2.9-1.3 5.3-3.3 7-5.9zM63.9 0c-26.5 0-49 19-55 44.5V47H48c2.7-4.3 7.3-7.2 12.6-7.6 1-.1 2-.1 3.2-.1h402.6V47h38.3V0z" style="fill:#898b8d"></path><path d="M466.1 157.7V197H319.5v-39.3zM45.9 315.4v39.3h146.6v-39.3zm0-157.7V197h146.6v-39.3zm273.6 157.7v39.3h146.6v-39.3z" style="fill:#58595b"></path><path d="M83.8 78.6H428v39.3H83.8zm0 315.9H428v39.3H83.8z" style="fill:#403f41"></path><linearGradient id="opnsense-v1_svg__a" x1="-1460.617" x2="-1375.11" y1="1248.095" y2="1248.095" gradientTransform="matrix(.1853 .356 .6722 -.353 -90.66 993.802)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="m466.5 78.6 38.2-20.5.1-39.5-38.3 20.7" style="fill:url(#opnsense-v1_svg__a)"></path><linearGradient id="opnsense-v1_svg__b" x1="4.634" x2="50.301" y1="462.6" y2="462.6" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 64.5v-8.9c0-5.3 2.6-10 6.5-13l-34-18.5c-6.7 9.5-10.8 21.3-10.9 34l38.3 20.6v-14c.1-.1.1-.2.1-.2" style="fill:url(#opnsense-v1_svg__b)"></path><linearGradient id="opnsense-v1_svg__c" x1="-1587.887" x2="-1498.137" y1="-2208.165" y2="-2208.165" gradientTransform="matrix(-.1853 -.356 -.6722 .353 -1743.836 694.098)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 472.7v-38.9L7.3 454.5v39.7l39.9-21.5z" style="fill:url(#opnsense-v1_svg__c)"></path><linearGradient id="opnsense-v1_svg__d" x1="460.439" x2="504.436" y1="53" y2="53" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M466.5 456.4c0 5.5-2.7 10.3-6.9 13.2l34.2 18.4c6.8-9.5 10.8-21.2 10.9-33.8L466.5 434v12.8" style="fill:url(#opnsense-v1_svg__d)"></path><linearGradient id="opnsense-v1_svg__e" x1="2521.902" x2="2684.464" y1="-2476.233" y2="-2476.233" gradientTransform="matrix(-1.508 -1.0166 -3.1265 -1.519 -3697.438 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 197v-.4l-72.4-38.9H45.9v.2l72.5 39.1z" style="fill:url(#opnsense-v1_svg__e)"></path><linearGradient id="opnsense-v1_svg__f" x1="-1594.953" x2="-1432.391" y1="278.458" y2="278.458" gradientTransform="matrix(1.508 -1.0166 3.1265 -1.519 1804.196 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 157.7h-74l-72.6 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__f)"></path><linearGradient id="opnsense-v1_svg__g" x1="-4327.142" x2="-4164.581" y1="1572.387" y2="1572.387" gradientTransform="matrix(1.508 1.0166 3.1265 1.519 1863.938 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 354.7v-.4l-72.4-38.9h-74.2v.2l72.6 39.1z" style="fill:url(#opnsense-v1_svg__g)"></path><linearGradient id="opnsense-v1_svg__h" x1="-413.668" x2="-246.99" y1="-1046.618" y2="-1046.618" gradientTransform="matrix(-1.508 1.0166 -3.1265 1.519 -3638.692 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 315.4h-74.1l-72.5 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__h)"></path><linearGradient id="opnsense-v1_svg__i" x1="74.725" x2="261.062" y1="132.65" y2="132.65" gradientTransform="matrix(.9914 0 0 -1 -66.782 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 157.7V197L7.3 97.4V58.1z" style="fill:url(#opnsense-v1_svg__i)"></path><linearGradient id="opnsense-v1_svg__j" x1="-2461.056" x2="-2274.718" y1="132.65" y2="132.65" gradientTransform="matrix(-.9914 0 0 -1 -1935.19 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 157.7V197l185.5-99.6V58.1z" style="fill:url(#opnsense-v1_svg__j)"></path><linearGradient id="opnsense-v1_svg__k" x1="-2291.845" x2="-2105.508" y1="-739.55" y2="-739.55" gradientTransform="matrix(-.9914 0 0 1 -1767.435 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 355.2v-39.8L504.7 415v39.7z" style="fill:url(#opnsense-v1_svg__k)"></path><linearGradient id="opnsense-v1_svg__l" x1="-94.103" x2="91.934" y1="-739.55" y2="-739.55" gradientTransform="matrix(.9914 0 0 1 100.993 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 355.2v-39.8L7.3 415v39.7z" style="fill:url(#opnsense-v1_svg__l)"></path><path d="m319.2 276.1 108.9 58.5v-39.7l-35.3-18.8h111.9v-39.8H392.8l35.3-18.8v-39.3l-108.9 58.1zM83.8 334.6l109-58.5v-39.8l-109-58.1v39.3l35.7 18.8H7.3v39.8h111.9l-35.3 18.8v39.7z" style="fill:#e24525"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2971.700036728428,480.7287465212985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2645.5845448279656,970.7820678889219)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-server-security" viewBox="0 0 24 24" width="164.4" height="164.4" x="-82.2" y="-82.2" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"><path d="M3,1H19A1,1 0 0,1 20,2V6A1,1 0 0,1 19,7H3A1,1 0 0,1 2,6V2A1,1 0 0,1 3,1M3,9H19A1,1 0 0,1 20,10V10.67L17.5,9.56L11,12.44V15H3A1,1 0 0,1 2,14V10A1,1 0 0,1 3,9M3,17H11C11.06,19.25 12,21.4 13.46,23H3A1,1 0 0,1 2,22V18A1,1 0 0,1 3,17M8,5H9V3H8V5M8,13H9V11H8V13M8,21H9V19H8V21M4,3V5H6V3H4M4,11V13H6V11H4M4,19V21H6V19H4M17.5,12L22,14V17C22,19.78 20.08,22.37 17.5,23C14.92,22.37 13,19.78 13,17V14L17.5,12M17.5,13.94L15,15.06V17.72C15,19.26 16.07,20.7 17.5,21.06V13.94Z" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2466.35986328125" y="741.6801147460938" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 40px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2466.35986328125" dy="0">Double click on desktop</tspan><tspan x="2466.35986328125" dy="48">or long press on mobile</tspan><tspan x="2466.35986328125" dy="48">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2486.35986328125" cy="701.6801147460938" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2486.35986328125" y="701.6801147460938" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2103.968290880771" y1="268" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1773.8400660428597" y2="666.5758233298659" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1931.1978950081452" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2342.2663764534577" y2="631.7681967180296" class="minimap-edge"></line><line x1="2103.968290880771" y1="268" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2971.700036728428" y2="480.7287465212985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2103.968290880771" cy="268" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1773.8400660428597" cy="666.5758233298659" r="40" class="minimap-node"></circle><circle cx="1931.1978950081452" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2342.2663764534577" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2971.700036728428" cy="480.7287465212985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2645.5845448279656" cy="970.7820678889219" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors', 
         signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
      
       indicator.setAttribute('r', radius);
      
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
      
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      
      
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      
      function startAutoPing() {
       stopAutoPing();
       
       checkAllNodesStatus();
       updateAutoPingLastRun();
       
       autoPingSecondsRemaining = autoPingInterval;
       
      
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       
       updateAutoPingCountdown();
      }
      
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {};
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
      
      const MobileManager = {
        isMobile: false,
        detect() {
      
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
       const existing = document.getElementById("minimap-mini");
       if (existing) { minimapMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
	   const existing = document.getElementById("draw-toolbar-mini");
       if (existing) { drawToolbarMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const existing = document.getElementById("topology-toolbar-mini");
       if (existing) { topologyToolbarMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }  
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       
       viewOnlyClickCount++;
       
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        
        document.body.classList.add("view-only-inspect");
        
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
      
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {  
       activeLayers.clear(); 
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");    
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");    
       if (document.getElementById("layer-security").checked) activeLayers.add("security");     
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();    
      }
      
      function isNodeVisible(nodeId) {  
       const node = NODE_DATA[nodeId];    
       if (!node) return false;     
       const nodeLayer = node.layer || "physical";     
       return activeLayers.has(nodeLayer);     
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       if (autoPingEnabled) {
        startAutoPing();
       }
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
            
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";       
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
        
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         
         svg.appendChild(rackGroup);
        }
      
        const centerX = CANVAS_WIDTH / 2;
      
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
      
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode || 
              fromNode.assignedRack !== currentView.rackId || 
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         svg.appendChild(path);
         svg.appendChild(pathHit);
         
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
      
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
          
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
         if (!savedSizes[id]) {
          if (window.innerWidth <= 380) r = 120;
          else if (window.innerWidth <= 768) r = 140;
          else if (window.innerWidth <= 1024) r = 70;
         }
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           
           g.insertBefore(groupIndicator, g.firstChild);
         }
         
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
         
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
         
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          isDragging = true;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
      
      
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 e.preventDefault();
                 e.stopPropagation();
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
      
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        
        forgeTheLegend();
        updateMinimap();
       }
      
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
      
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
      
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
      
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
      
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
      
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";	
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }    
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display = 
          data.ping.protocol === 'custom' ? 'block' : 'none';
         
         updatePingStatusDisplay(id);
        }
       }
      
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
      
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
	   
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Delete this line note?", () => {
           edge.notes.splice(i, 1);
          
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
         txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          edge.notes[i] = txt.textContent;
         
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          
          if (e.changedTouches.length !== 1) return;
          
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            
            exitRack();
            
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (isSelecting) {
          updateSelection(e);
          return;
         }
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
      
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
      
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
      
        }
       });
       const applyStyle = (property, value) => {
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display = 
         e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        edge.width = v;
       
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        edge.color = color;
       
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.direction = document.getElementById("edge-direction").value;
       
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.lineStyle = document.getElementById("edge-line-style").value;
       
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.notes.push(txt);
       
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
	   
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
	  
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
         
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        EDGE_DATA.list.push(newEdge);
       
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
      
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
      
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
      
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
      
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
        
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone"); 
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
       const textToggleBtn = document.getElementById("text-toggle");
       
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        
        updateTextDeleteButtons();
       }
       
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        
        forgeTheTopology();
        
        showTextPanel(newId);
       }
       
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
      
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {	 
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";	 
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
      
        
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         
         function handleMove(e) {
           if (!isResizing) return;
           
           const pos = getClientPos(e);
           
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           
           e.preventDefault();
         }
         
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		logAuditEvent("export", `Exported JSON: ${a.download}`);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
      
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,  
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
      
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
      
       page: PAGE_STATE,
      
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
      
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       
       savedTopologyView: savedTopologyView,
       
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
      
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });  
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); 
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
       
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
       
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       
       if (!event.shiftKey) {
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
       }
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       
       const box = { x, y, width, height };
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!event.shiftKey) {
         selectedEdges.delete(edge.id);
        }
       });
       
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!event.shiftKey) {
         selectedRects.delete(rect.id);
        }
       });
       
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!event.shiftKey) {
         selectedTexts.delete(text.id);
        }
       });
       
       updateAllSelectionVisuals();
      }
      
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       
       pushUndo("clone node");
       
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
      
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) => 
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       
       forgeTheTopology();
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        
        if (!hasItems || !isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        
        forgeTheTopology();
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
      
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
        
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
         
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
         
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
         
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      
      function searchNodes(query) {
       clearSearchHighlight();
       
       if (!query || query.trim() === "") return;
       
       const lowerQuery = query.toLowerCase();
       const matchingIds = [];
       
       Object.entries(NODE_DATA).forEach(([id, node]) => {
        const searchableText = [
         node.name,
         node.ip,
         node.role,
         ...(node.tags || []),
         node.mac || "",
         node.rackUnit || ""
        ].join(" ").toLowerCase();
        
        if (searchableText.includes(lowerQuery)) {
         matchingIds.push(id);
        }
       });
       
       highlightSearchResults(matchingIds);
      }
      
      function highlightSearchResults(nodeIds) {
       clearSearchHighlight();
       nodeIds.forEach(id => {
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         nodeGroup.classList.add("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".node-group").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       
      
       forgeTheTopology();
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
      
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
      
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         
         pushUndo("add rack");
         
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false, 
         groupId: null 
        };
        
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
		logAuditEvent("clear", "Cleared all data from canvas");
        clearAllModal.classList.remove("active");
      
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      
      stopAutoPing();
      
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
      
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
      
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });	   
    </script>
  
</body></html>