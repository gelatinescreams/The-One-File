<!DOCTYPE html>
<html lang="en" style="--panel: #0b0e13; --panel-alt: #10141b; --accent: #4fd1c5; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 100px; --sidebar-width: 435px; --mobile-footer-height: 20vh;"><head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>The One File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- 
     * ==================================================================================
     * THE ONE FILE
     * "There can be only one". A all in one file topology maker.
     * 
     * This is your last backup when all others fail. A completely self-contained
     * network topology visualization tool that works as a single HTML file.
     * Open it anywhere, anytime and the idea lives forever.
     * ==================================================================================
-->
  <style>

    :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    input,
    textarea,
    [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
    }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }

    header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .editable-page-title:hover {
      opacity: 0.7;
    }

    .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
    }

    .save-btn:hover {
      opacity: 0.9;
    }

    .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
    }

    .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
    }

    #settings-btn {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
    }

    #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
    }

    main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
    }

    @media(max-width: 1024px){
      main {
        grid-template-columns: 1fr var(--sidebar-width, 300px);
      }
    }

    @media(max-width: 768px){
      main {
        grid-template-columns: 1fr;
        grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
        grid-template-rows: 1fr 0;
      }

      .details-panel {
        max-height: var(--mobile-footer-height, 40vh);
        height: 100%;
      }
    }

    @media(max-width: 380px){
      main {
        grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
    }

    .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
    }

    .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 20;
      font-size: 13px;
    }

    .topology-toolbar label {
      color: var(--text-soft);
    }

    .topology-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
    }

    .topology-toolbar button {
      padding: 4px 10px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
    }

    .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 20;
      font-size: 13px;
      pointer-events: auto;
    }

    .draw-toolbar button {
      padding: 4px 8px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
    }

    .draw-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
    }

    .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: none;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
    }

    .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
    }

    .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
    }

    .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
    }

    .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
    }

    .canvas-viewport.panning {
      cursor: grabbing !important;
    }

    .canvas-viewport.panning * {
      cursor: grabbing !important;
    }

    .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: 
        linear-gradient(rgba(71, 85, 105, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(71, 85, 105, 0.1) 1px, transparent 1px),
        linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(71, 85, 105, 0.05) 1px, transparent 1px);
      background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;
      background-position: -1px -1px, -1px -1px, -1px -1px, -1px -1px;
    }

    .zoom-toolbar {
      position: absolute;
      bottom: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 6px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 20;
    }

    .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--text-soft);
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
    }

    .zoom-toolbar .divider {
      height: 1px;
      background: var(--edge-main);
      margin: 2px 0;
    }

    .minimap-container {
      position: absolute;
      bottom: 10px;
      right: 60px;
      width: 150px;
      height: 100px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 19;
      overflow: hidden;
    }

    .minimap-container svg {
      width: 100%;
      height: 100%;
    }

    .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
    }

    .minimap-node {
      fill: var(--text-soft);
    }

    .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
    }

    .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .canvas-hint.visible {
      opacity: 1;
    }

    .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: .75;
      transition: .25s ease-in-out;
      cursor: pointer;
    }

    .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
    }

    .edge.active {
      opacity: 1;
      stroke-width: 7;
    }

    .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
    }

    .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
    }

    .node-circle {
      fill: #0c111a;
      stroke: #1e293b;
      stroke-width: 4;
      transition: .25s ease;
      transform-origin: center center;
    }

    .node-group:hover .node-circle {
      transform: scale(1.08);
      filter: drop-shadow(0 0 10px rgba(79,209,197,.45));
    }

    .node-group:hover .node-label,
    .node-group:hover .node-sub {
      transform: scale(1.08);
    }

    .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
    }

    @keyframes pulse {
      0% {
        filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50%{
        filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100%{
        filter: drop-shadow(0 0 4px #4fd1c5);
      }
    }

    .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
    }

    .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
    }

    @media(max-width: 1024px){
      .node-label {
        font-size: 28px;
      }
      .node-sub {
        font-size: 20px;
      }
    }

    @media(max-width: 768px){
      .node-label {
        font-size: 70px;
      }
      .node-sub {
        font-size: 50px;
      }
    }

    @media(max-width: 380px){
      .node-label {
        font-size: 60px;
      }
      .node-sub {
        font-size: 42px;
      }
    }

    .details-panel {
      background: var(--panel-alt);
      padding: 22px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition: width 0.3s ease, min-width 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
    }

	.details-panel {
	  min-width: 260px !important;
	}

	.details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
	}

    .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
    }

	body {
      overflow-x: hidden;
      overflow-y: hidden;   
	}

	main {
      overflow: hidden;     
	}

	.details-panel {
	  overflow-y: auto !important;
      overflow-x: hidden;
	}

    .details-panel.collapsed {
      min-width: 0 !important;
	}

    .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition: background 0.2s, color 0.2s;
    }

    .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
    }

    .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
    }

    .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
    }

    .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
    }

    .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }

    .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
    }

    .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
    }

    .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
    }

    .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
    }

    .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }

    .style-section summary::-webkit-details-marker {
      display: none;
    }

	.password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff; 
      z-index: 9999;
	}

    .style-section summary::after {
      content: '‚ñº';
      transition: transform 0.2s;
    }

    .style-section[open] summary::after {
      transform: rotate(180deg);
    }

    .style-content {
      margin-top: 10px;
    }

    .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
    }

    .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
    }

    .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
    }

    .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
    }

    .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
    }

    .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .editable-text:hover {
      opacity: 0.7;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
    }

    .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
    }

    .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
    }

    .modal-content input:not([type="color"]),
    .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
    }

    .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }

    .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
    }

    .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
    }

    .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
    }

    .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
    }

    .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
    }

    .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
    }

    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .badge {
      border: 1px solid var(--edge-main);
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
    }

    .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
    }

    .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
    }

    .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .list li:hover {
      color: var(--accent);
    }

    .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
    }

    .list li:hover .delete-note {
      opacity: 1;
    }

    .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
    }
  </style>
</head>
<body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);">

  <div class="modal" id="edit-modal">
    <div class="modal-content">
      <h3 id="modal-title">Edit Name</h3>
      <input type="text" id="modal-input">
      <div class="modal-buttons">
        <button class="btn-cancel" id="modal-cancel">Cancel</button>
        <button class="btn-save" id="modal-save">Save</button>
      </div>
    </div>
  </div>

  <div class="modal confirm-modal" id="confirm-modal">
    <div class="modal-content">
      <h3>Confirm</h3>
      <p id="confirm-message">Are you sure you want to delete this line?</p>
      <div class="modal-buttons">
        <button class="btn-cancel" id="confirm-cancel">Cancel</button>
        <button class="btn-delete" id="confirm-delete">Delete</button>
      </div>
    </div>
  </div>

  <div class="modal" id="save-info-modal">
    <div class="modal-content">
      <h3>Why do I need to save?</h3>
      <p>
        Browsers are not allowed to overwrite local files automatically.
        When you click <strong>Save File</strong>, this page generates a new updated
        HTML file that contains all of your changes. Replace your old file with the
        new one to keep your edits.
      </p>
      <p style="margin-top:12px; padding-top:12px; border-top:1px solid var(--edge-main);">
        <strong>üîí Encryption:</strong> Check the "Encrypt" box before saving to password protect
        your data. You'll need the password to open the file later. No recovery possible!!
      </p>
      <div class="modal-buttons">
        <button class="btn-cancel" id="save-info-close">Close</button>
      </div>
    </div>
  </div>

  <div class="modal" id="settings-modal">
    <div class="modal-content" style="max-width: 400px;">
      <h3>Page Settings</h3>

      <details class="style-section" open="">
        <summary>Background</summary>
        <div class="style-content">
          <div class="style-row">
            <label>Solid Color</label>
            <input type="color" id="page-bg-color" value="#050608">
          </div>
          <p style="margin-top:4px; font-size:12px; color:var(--text-soft);">
            Change to apply a flat background color.
          </p>
        </div>
      </details>

      <details class="style-section" open="">
        <summary>Top Bar</summary>
        <div class="style-content">
          <div class="style-row">
            <label>Background</label>
            <input type="color" id="topbar-bg-color" value="#0b0e13">
          </div>
          <div class="style-row">
            <label>Border</label>
            <input type="color" id="topbar-border-color" value="#1f2533">
          </div>
        </div>
      </details>

      <details class="style-section" open="">
        <summary>Theme Colors</summary>
        <div class="style-content">
          <div class="style-row">
            <label>Panel</label>
            <input type="color" id="panel-color" value="#0b0e13">
          </div>
          <div class="style-row">
            <label>Panel Alt</label>
            <input type="color" id="panel-alt-color" value="#10141b">
          </div>
          <div class="style-row">
            <label>Accent</label>
            <input type="color" id="accent-color" value="#4fd1c5">
          </div>
          <div class="style-row">
            <label>Danger</label>
            <input type="color" id="danger-color" value="#f56565">
          </div>
          <div class="style-row">
            <label>Text Main</label>
            <input type="color" id="text-main-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Text Soft</label>
            <input type="color" id="text-soft-color" value="#94a3b8">
          </div>
        </div>
      </details>

      <details class="style-section" open="">
        <summary>Import / Export Data</summary>
        <div class="style-content">
          <p style="margin-bottom:12px; font-size:13px; color:var(--text-soft);">
            Export/Import your data to upgrade/downgrade versions of The One File.
          </p>
          <button id="export-data-btn" style="width: 100%; margin-bottom: 10px; padding: 10px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
            Export Data (JSON)
          </button>
          <button id="import-data-btn" style="width: 100%; padding: 10px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
            Import Data (JSON)
          </button>
          <input type="file" id="import-data-file" accept=".json" style="display: none;">
        </div>
      </details>

      <div class="modal-buttons">
        <button class="btn-cancel" id="settings-close">Close</button>
      </div>
    </div>
  </div>

  <div class="modal" id="add-node-modal">
    <div class="modal-content">
      <h3>Add New Node</h3>
      <label style="display:block; margin-bottom:4px; color:var(--text-soft); font-size:13px;">Name</label>
      <input type="text" id="new-node-name" placeholder="e.g. web-server">
      <label style="display:block; margin-bottom:4px; color:var(--text-soft); font-size:13px;">IP / Subtitle</label>
      <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
      <label style="display:block; margin-bottom:4px; color:var(--text-soft); font-size:13px;">Tags (comma separated)</label>
      <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
      <label style="display:block; margin-bottom:4px; color:var(--text-soft); font-size:13px;">Shape</label>
      <select id="new-node-shape">
        <optgroup label="Basic Shapes">
          <option value="circle">Circle</option>
          <option value="square">Square</option>
          <option value="rectangle">Rectangle</option>
          <option value="triangle">Triangle</option>
          <option value="hexagon">Hexagon</option>
          <option value="diamond">Diamond</option>
          <option value="star">Star</option>
          <option value="stop-sign">Stop Sign</option>
        </optgroup>
        <optgroup label="Network Equipment">
          <option value="server">Server</option>
          <option value="pc">PC / Desktop</option>
          <option value="laptop">Laptop</option>
          <option value="phone">Phone / Mobile</option>
          <option value="router">Router</option>
          <option value="switch">Switch</option>
          <option value="firewall">Firewall</option>
          <option value="cloud">Cloud</option>
          <option value="database">Database</option>
          <option value="printer">Printer</option>
        </optgroup>
      </select>
      <div class="modal-buttons">
        <button class="btn-cancel" id="add-node-cancel">Cancel</button>
        <button class="btn-save" id="add-node-save">Add Node</button>
      </div>
    </div>
  </div>

  <div class="modal confirm-modal" id="clear-all-modal">
    <div class="modal-content">
      <h3>Clear All Nodes</h3>
      <p>This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure?</p>
      <div class="modal-buttons">
        <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
        <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
      </div>
    </div>
  </div>

  <header>
    <div class="title-block">
      <h1 id="page-title" class="editable-page-title">The One File</h1>
      <div class="save-row">
        <button id="save-file-btn" class="save-btn" type="button">Save File</button>
        <label style="display:flex; align-items:center; gap:4px; font-size:12px; color:var(--text-soft); cursor:pointer; user-select:none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor:pointer;">
          <span title="Encrypt data with password">Encrypt</span>
        </label>
        <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
      </div>
    </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="add-node-btn" class="save-btn" title="Add new node" style="background:var(--accent);">+ Node</button>
      <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:14px; font-weight:600;">Clear All</button>
	  <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding:6px 12px; background:var(--panel); color:var(--text-main); border:1px solid var(--edge-main); border-radius:6px; cursor:pointer; font-size:14px; font-weight:600;">üì∑ PNG</button>	  
      <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding:6px 12px; background:var(--panel); color:var(--text-main); border:1px solid var(--edge-main); border-radius:6px; cursor:pointer; font-size:14px; font-weight:600;">üìÑ SVG</button>
	  <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
  </header>

  <main>
    <section class="topology-panel">

      <div class="draw-toolbar" id="draw-toolbar">
        <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
        <input type="color" id="draw-color" value="#f97316" title="Line color">
        <select id="draw-style" title="Line style">
          <option value="solid">Solid</option>
          <option value="dashed">Dashed</option>
          <option value="dotted">Dotted</option>
        </select>
        <select id="draw-arrow" title="Arrow direction">
          <option value="none">No arrows</option>
          <option value="forward">‚Üí Right</option>
          <option value="backward">‚Üê Left</option>
          <option value="both">‚Üî Both</option>
        </select>
        <button id="draw-undo" style="display: none;" title="Undo last point">Undo</button>
      </div>

      <div class="topology-toolbar" id="topology-toolbar" style="display: none;">
        <label for="add-line-select">Add line to:</label>
        <select id="add-line-select"><option value="wew">wew</option></select>
        <input type="color" id="add-line-color" value="#475569" title="Line color" style="width:30px; height:24px; border:1px solid var(--edge-main); border-radius:4px; cursor:pointer; background:transparent; padding:0;">
        <select id="add-line-direction" title="Line direction">
          <option value="none">No arrows</option>
          <option value="forward">‚Üí Forward</option>
          <option value="backward">‚Üê Backward</option>
          <option value="both">‚Üî Both</option>
        </select>
        <button id="add-line-btn">Add</button>
      </div>

      <div class="canvas-hint" id="canvas-hint">Scroll to zoom ‚Ä¢ Drag empty space to pan ‚Ä¢ Hold Space + drag</div>

      <div class="legend-container" id="edge-legend" style="display: none;"><div class="legend-title">Line Legend</div></div>

      <div class="canvas-viewport" id="canvas-viewport">
        <svg id="map" viewBox="914.6107126923603 654.9372179200348 1972.4132256089326 1479.3099192066995" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="rgba(71, 85, 105, 0.3)" stroke-width="2" stroke-dasharray="10 5" rx="8"></rect></svg>
      </div>

      <div class="minimap-container" id="minimap-container">
        <svg id="minimap" viewBox="0 0 4000 3000">
          <rect class="minimap-viewport" id="minimap-viewport" x="914.6107126923603" y="654.9372179200348" width="1972.4132256089326" height="1479.3099192066995"></rect>
        </svg>
      </div>

      <div class="zoom-toolbar" id="zoom-toolbar">
        <button id="zoom-in-btn" title="Zoom in">+</button>
        <div class="zoom-level" id="zoom-level">203%</div>
        <button id="zoom-out-btn" title="Zoom out">-</button>
        <div class="divider"></div>
        <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
        <button id="zoom-reset-btn" title="Reset view">R</button>
      </div>
    </section>

    <aside class="details-panel" id="details-panel">

      <button class="sidebar-toggle" id="sidebar-toggle" title="Toggle sidebar">‚óÄ</button>

      <div id="node-panel" style="display: none;">
        <div class="details-name editable-text" id="node-name">wewew</div>
        <div class="details-ip editable-text" id="node-ip">wew</div>
        <div class="details-role" id="node-role"></div>
        <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>wew</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add</span></div>

        <div class="size-controls">
          <label>Size:</label>
          <input type="range" id="size-slider" min="20" max="200" value="55">
          <span id="size-value">55</span>
          <button id="reset-size">Reset</button>
        </div>

        <details class="style-section">
          <summary>Styling</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Screen:</label>
              <select id="style-scope">
                <option value="all">All</option>
                <option value="desktop">Desktop</option>
                <option value="tablet">Tablet</option>
                <option value="mobile">Mobile</option>
                <option value="fold">Fold</option>
              </select>
            </div>

            <div class="style-row">
              <label>Shape:</label>
              <select id="shape-select">
                <optgroup label="Basic Shapes">
                  <option value="circle">Circle</option>
                  <option value="square">Square</option>
                  <option value="rectangle">Rectangle</option>
                  <option value="triangle">Triangle</option>
                  <option value="hexagon">Hexagon</option>
                  <option value="diamond">Diamond</option>
                  <option value="star">Star</option>
                  <option value="stop-sign">Stop Sign</option>
                </optgroup>
                <optgroup label="Network Equipment">
                  <option value="server">Server</option>
                  <option value="pc">PC / Desktop</option>
                  <option value="laptop">Laptop</option>
                  <option value="phone">Phone / Mobile</option>
                  <option value="router">Router</option>
                  <option value="switch">Switch</option>
                  <option value="firewall">Firewall</option>
                  <option value="cloud">Cloud</option>
                  <option value="database">Database</option>
                  <option value="printer">Printer</option>
                </optgroup>
              </select>
            </div>

            <div class="style-row">
              <label>Circle Color:</label>
              <input type="color" id="circle-color" value="#1e293b">
            </div>

            <div class="style-row">
              <label>Title Color:</label>
              <input type="color" id="title-color" value="#e2e8f0">
            </div>

            <div class="style-row">
              <label>Title Font:</label>
              <select id="title-font">
                <option value="system-ui, sans-serif">System UI</option>
                <option value="monospace">Monospace</option>
                <option value="serif">Serif</option>
                <option value="cursive">Cursive</option>
                <option value="'Courier New', monospace">Courier</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="'Times New Roman', serif">Times</option>
              </select>
            </div>

            <div class="style-row">
              <label>Title Size:</label>
              <input type="number" id="title-size" min="8" max="100" value="18">
            </div>

            <div class="style-row">
              <label>Sub Color:</label>
              <input type="color" id="sub-color" value="#94a3b8">
            </div>

            <div class="style-row">
              <label>Sub Font:</label>
              <select id="sub-font">
                <option value="system-ui, sans-serif">System UI</option>
                <option value="monospace">Monospace</option>
                <option value="serif">Serif</option>
                <option value="cursive">Cursive</option>
                <option value="'Courier New', monospace">Courier</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="'Times New Roman', serif">Times</option>
              </select>
            </div>

            <div class="style-row">
              <label>Sub Size:</label>
              <input type="number" id="sub-size" min="6" max="80" value="13">
            </div>

            <div style="margin-top:12px; padding-top:10px; border-top:1px solid var(--edge-main);">
              <div style="font-size:12px; color:var(--text-soft); margin-bottom:8px; text-transform:uppercase;">Text Position</div>
              <div class="style-row">
                <label>Name Y:</label>
                <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width:60px;">
              </div>
              <div class="style-row">
                <label>Name X:</label>
                <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width:60px;">
              </div>
              <div class="style-row">
                <label>IP Y:</label>
                <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width:60px;">
              </div>
              <div class="style-row">
                <label>IP X:</label>
                <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width:60px;">
              </div>
            </div>

            <button id="reset-styles" style="width: 100%; margin-top: 10px; padding: 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: clamp(13px, 1.5vw, 17px);">
              Reset Styles
            </button>
          </div>
        </details>

        <div class="section-label">Notes</div>
        <ul class="list" id="node-notes"></ul>
        <div style="margin-top: 10px; display: flex; gap: 8px;">
          <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1; padding: 8px 12px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: clamp(14px, 1.6vw, 18px);">
          <button id="add-note-btn" style="padding: 8px 16px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: clamp(14px, 1.6vw, 18px); font-weight: 600;">
            Add
          </button>
        </div>
      <button id="delete-node-btn" style="margin-top: 15px; padding: 10px 16px; background: var(--danger); color: rgb(255, 255, 255); border: none; border-radius: 6px; cursor: pointer; font-size: clamp(14px, 1.6vw, 18px); font-weight: 600; width: 100%;">Delete Node</button></div>

      <div id="edge-panel" style="display: none;">
        <div class="details-name" id="edge-title">Custom line</div>

        <div class="style-row" style="margin-top:10px;">
          <label>Width:</label>
          <input type="number" id="edge-width" min="1" max="20" value="4">
        </div>

        <div class="style-row">
          <label>Color:</label>
          <input type="color" id="edge-color" value="#475569">
        </div>

        <div class="style-row">
          <label>Line Style:</label>
          <select id="edge-line-style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
        </div>

        <div class="style-row">
          <label>Direction:</label>
          <select id="edge-direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Bidirectional</option>
          </select>
        </div>

        <div class="section-label">Line Notes</div>
        <ul class="list" id="edge-notes"></ul>
        <div style="margin-top: 10px; display: flex; gap: 8px;">
          <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1; padding: 8px 12px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: clamp(14px, 1.6vw, 18px);">
          <button id="add-edge-note" style="padding: 8px 16px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: clamp(14px, 1.6vw, 18px); font-weight: 600;">
            Add
          </button>
        </div>

        <button id="delete-edge" style="margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600;">
          Delete Line
        </button>
      </div>
	   <details class="style-section" open="">
        <summary>Page Layout</summary>
        <div class="style-content">
          <div class="style-row">
            <label>Topbar Height</label>
            <input type="range" id="topbar-height" min="40" max="100" value="52" style="flex:1;">
            <span id="topbar-height-val" style="min-width:35px; text-align:right;">100px</span>
          </div>
          <div class="style-row">
            <label>Sidebar Width</label>
            <input type="range" id="sidebar-width" min="200" max="600" value="350" style="flex:1;">
            <span id="sidebar-width-val" style="min-width:45px; text-align:right;">435px</span>
          </div>
          <div class="style-row">
            <label>Mobile Footer Height</label>
            <input type="range" id="mobile-footer-height" min="20" max="70" value="40" style="flex:1;">
            <span id="mobile-footer-height-val" style="min-width:45px; text-align:right;">20%</span>
          </div>
        </div>
      </details>
    </aside>

  </main>

  <script id="nodes-json" type="application/json">{
  "internet": {
    "shape": "cloud",
    "name": "Internet",
    "ip": "0.0.0.0",
    "role": "External",
    "tags": ["External"],
    "notes": ["Public internet"]
  },
  "edge-firewall": {
    "shape": "firewall",
    "name": "Edge Firewall",
    "ip": "203.0.113.1",
    "role": "Security",
    "tags": ["Firewall", "Palo Alto", "HA"],
    "notes": ["PA-5220", "Active-Passive HA", "10Gbps throughput"]
  },
  "core-router-1": {
    "shape": "router",
    "name": "Core Router 1",
    "ip": "10.0.0.1",
    "role": "Core",
    "tags": ["Router", "Cisco", "BGP"],
    "notes": ["Cisco Catalyst 9600", "OSPF + BGP", "Redundant PSU"]
  },
  "core-router-2": {
    "shape": "router",
    "name": "Core Router 2",
    "ip": "10.0.0.2",
    "role": "Core",
    "tags": ["Router", "Cisco", "BGP"],
    "notes": ["Cisco Catalyst 9600", "OSPF + BGP", "Redundant PSU"]
  },
  "core-switch-1": {
    "shape": "switch",
    "name": "Core Switch 1",
    "ip": "10.0.0.10",
    "role": "Core",
    "tags": ["Switch", "Cisco", "Stack"],
    "notes": ["Cisco Catalyst 9500", "VSS", "40Gbps uplinks"]
  },
  "core-switch-2": {
    "shape": "switch",
    "name": "Core Switch 2",
    "ip": "10.0.0.11",
    "role": "Core",
    "tags": ["Switch", "Cisco", "Stack"],
    "notes": ["Cisco Catalyst 9500", "VSS", "40Gbps uplinks"]
  },
  "load-balancer": {
    "shape": "server",
    "name": "Load Balancer",
    "ip": "10.1.0.10",
    "role": "DMZ",
    "tags": ["F5", "HA", "DMZ"],
    "notes": ["F5 BIG-IP", "SSL offloading", "Active-Standby"]
  },
  "web-server-1": {
    "shape": "server",
    "name": "Web Server 1",
    "ip": "10.1.0.20",
    "role": "DMZ",
    "tags": ["Web", "Nginx", "DMZ"],
    "notes": ["Ubuntu 22.04", "Nginx reverse proxy", "SSL certificates"]
  },
  "web-server-2": {
    "shape": "server",
    "name": "Web Server 2",
    "ip": "10.1.0.21",
    "role": "DMZ",
    "tags": ["Web", "Nginx", "DMZ"],
    "notes": ["Ubuntu 22.04", "Nginx reverse proxy", "SSL certificates"]
  },
  "web-server-3": {
    "shape": "server",
    "name": "Web Server 3",
    "ip": "10.1.0.22",
    "role": "DMZ",
    "tags": ["Web", "Nginx", "DMZ"],
    "notes": ["Ubuntu 22.04", "Nginx reverse proxy", "SSL certificates"]
  },
  "internal-fw": {
    "shape": "firewall",
    "name": "Internal Firewall",
    "ip": "10.2.0.1",
    "role": "Security",
    "tags": ["Firewall", "FortiGate"],
    "notes": ["FortiGate 600E", "IPS enabled", "App control"]
  },
  "ad-dc-1": {
    "shape": "server",
    "name": "Domain Controller 1",
    "ip": "10.2.1.10",
    "role": "Internal",
    "tags": ["AD", "DNS", "Windows"],
    "notes": ["Windows Server 2022", "Primary DC", "FSMO roles"]
  },
  "ad-dc-2": {
    "shape": "server",
    "name": "Domain Controller 2",
    "ip": "10.2.1.11",
    "role": "Internal",
    "tags": ["AD", "DNS", "Windows"],
    "notes": ["Windows Server 2022", "Secondary DC", "Replica"]
  },
  "file-server": {
    "shape": "database",
    "name": "File Server",
    "ip": "10.2.1.20",
    "role": "Internal",
    "tags": ["Storage", "SMB", "Windows"],
    "notes": ["Windows Server 2022", "50TB storage", "DFS replication"]
  },
  "db-primary": {
    "shape": "database",
    "name": "Database Primary",
    "ip": "10.3.0.10",
    "role": "Data Center",
    "tags": ["Database", "PostgreSQL", "Primary"],
    "notes": ["PostgreSQL 15", "Primary node", "64GB RAM"]
  },
  "db-replica": {
    "shape": "database",
    "name": "Database Replica",
    "ip": "10.3.0.11",
    "role": "Data Center",
    "tags": ["Database", "PostgreSQL", "Replica"],
    "notes": ["PostgreSQL 15", "Read replica", "Streaming replication"]
  },
  "app-server-1": {
    "shape": "server",
    "name": "App Server 1",
    "ip": "10.3.0.20",
    "role": "Data Center",
    "tags": ["Application", "Java", "Production"],
    "notes": ["RHEL 9", "Tomcat cluster", "32GB RAM"]
  },
  "app-server-2": {
    "shape": "server",
    "name": "App Server 2",
    "ip": "10.3.0.21",
    "role": "Data Center",
    "tags": ["Application", "Java", "Production"],
    "notes": ["RHEL 9", "Tomcat cluster", "32GB RAM"]
  },
  "app-server-3": {
    "shape": "server",
    "name": "App Server 3",
    "ip": "10.3.0.22",
    "role": "Data Center",
    "tags": ["Application", "Java", "Production"],
    "notes": ["RHEL 9", "Tomcat cluster", "32GB RAM"]
  },
  "k8s-master-1": {
    "shape": "server",
    "name": "K8s Master 1",
    "ip": "10.3.1.10",
    "role": "Data Center",
    "tags": ["Kubernetes", "Master", "Container"],
    "notes": ["K8s 1.28", "Control plane", "etcd"]
  },
  "k8s-master-2": {
    "shape": "server",
    "name": "K8s Master 2",
    "ip": "10.3.1.11",
    "role": "Data Center",
    "tags": ["Kubernetes", "Master", "Container"],
    "notes": ["K8s 1.28", "Control plane", "etcd"]
  },
  "k8s-worker-1": {
    "shape": "server",
    "name": "K8s Worker 1",
    "ip": "10.3.1.20",
    "role": "Data Center",
    "tags": ["Kubernetes", "Worker", "Container"],
    "notes": ["64GB RAM", "24 cores", "NVMe storage"]
  },
  "k8s-worker-2": {
    "shape": "server",
    "name": "K8s Worker 2",
    "ip": "10.3.1.21",
    "role": "Data Center",
    "tags": ["Kubernetes", "Worker", "Container"],
    "notes": ["64GB RAM", "24 cores", "NVMe storage"]
  },
  "k8s-worker-3": {
    "shape": "server",
    "name": "K8s Worker 3",
    "ip": "10.3.1.22",
    "role": "Data Center",
    "tags": ["Kubernetes", "Worker", "Container"],
    "notes": ["64GB RAM", "24 cores", "NVMe storage"]
  },
  "backup-server": {
    "shape": "database",
    "name": "Backup Server",
    "ip": "10.4.0.10",
    "role": "Management",
    "tags": ["Backup", "Veeam"],
    "notes": ["Veeam B&R", "100TB capacity", "Offsite replication"]
  },
  "monitoring": {
    "shape": "server",
    "name": "Monitoring",
    "ip": "10.4.0.20",
    "role": "Management",
    "tags": ["Monitoring", "Grafana", "Prometheus"],
    "notes": ["Prometheus + Grafana", "500+ endpoints", "Alert manager"]
  },
  "vpn-gateway": {
    "shape": "firewall",
    "name": "VPN Gateway",
    "ip": "10.0.1.10",
    "role": "Security",
    "tags": ["VPN", "SSL-VPN", "Remote"],
    "notes": ["Cisco AnyConnect", "MFA enabled", "Split tunnel"]
  },
  "san-storage": {
    "shape": "database",
    "name": "SAN Storage",
    "ip": "10.5.0.10",
    "role": "Storage",
    "tags": ["SAN", "iSCSI", "FC"],
    "notes": ["Pure Storage", "200TB usable", "All-flash array"]
  },
  "branch-router": {
    "shape": "router",
    "name": "Branch Office Router",
    "ip": "10.100.0.1",
    "role": "Branch",
    "tags": ["Remote", "SD-WAN"],
    "notes": ["Site-to-site VPN", "SD-WAN enabled", "MPLS backup"]
  },
  "branch-switch": {
    "shape": "switch",
    "name": "Branch Switch",
    "ip": "10.100.0.10",
    "role": "Branch",
    "tags": ["Switch", "Remote"],
    "notes": ["24-port managed", "PoE+", "Local VLAN routing"]
  },
  "workstation-vlan": {
    "shape": "pc",
    "name": "User Workstations",
    "ip": "10.2.10.0/24",
    "role": "Internal",
    "tags": ["Users", "VLAN10"],
    "notes": ["250+ endpoints", "802.1X auth", "Windows 11"]
  },
  "guest-wifi-controller": {
    "shape": "router",
    "name": "WiFi Controller",
    "ip": "10.10.0.1",
    "role": "Guest",
    "tags": ["WiFi", "Controller"],
    "notes": ["Cisco WLC", "50+ APs", "Captive portal"]
  },
  "remote-workers": {
    "shape": "laptop",
    "name": "Remote Workers",
    "ip": "VPN Pool",
    "role": "Remote",
    "tags": ["VPN", "Remote"],
    "notes": ["200+ users", "SSL VPN", "MFA required"]
  },
  "mail-server": {
    "shape": "server",
    "name": "Mail Server",
    "ip": "10.2.2.10",
    "role": "Internal",
    "tags": ["Email", "Exchange"],
    "notes": ["Exchange 2019", "500 mailboxes", "Hybrid O365"]
  }
}</script>

  <!-- Topology state (will be updated on Save File) -->
  <script id="topology-state" type="application/json">{
  "nodeData": {
    "internet": {
      "shape": "cloud",
      "name": "Internet",
      "ip": "0.0.0.0",
      "role": "External",
      "tags": ["External"],
      "notes": ["Public internet"]
    },
    "edge-firewall": {
      "shape": "firewall",
      "name": "Edge Firewall",
      "ip": "203.0.113.1",
      "role": "Security",
      "tags": ["Firewall", "Palo Alto", "HA"],
      "notes": ["PA-5220", "Active-Passive HA", "10Gbps throughput"]
    },
    "core-router-1": {
      "shape": "router",
      "name": "Core Router 1",
      "ip": "10.0.0.1",
      "role": "Core",
      "tags": ["Router", "Cisco", "BGP"],
      "notes": ["Cisco Catalyst 9600", "OSPF + BGP", "Redundant PSU"]
    },
    "core-router-2": {
      "shape": "router",
      "name": "Core Router 2",
      "ip": "10.0.0.2",
      "role": "Core",
      "tags": ["Router", "Cisco", "BGP"],
      "notes": ["Cisco Catalyst 9600", "OSPF + BGP", "Redundant PSU"]
    },
    "core-switch-1": {
      "shape": "switch",
      "name": "Core Switch 1",
      "ip": "10.0.0.10",
      "role": "Core",
      "tags": ["Switch", "Cisco", "Stack"],
      "notes": ["Cisco Catalyst 9500", "VSS", "40Gbps uplinks"]
    },
    "core-switch-2": {
      "shape": "switch",
      "name": "Core Switch 2",
      "ip": "10.0.0.11",
      "role": "Core",
      "tags": ["Switch", "Cisco", "Stack"],
      "notes": ["Cisco Catalyst 9500", "VSS", "40Gbps uplinks"]
    },
    "load-balancer": {
      "shape": "server",
      "name": "Load Balancer",
      "ip": "10.1.0.10",
      "role": "DMZ",
      "tags": ["F5", "HA", "DMZ"],
      "notes": ["F5 BIG-IP", "SSL offloading", "Active-Standby"]
    },
    "web-server-1": {
      "shape": "server",
      "name": "Web Server 1",
      "ip": "10.1.0.20",
      "role": "DMZ",
      "tags": ["Web", "Nginx", "DMZ"],
      "notes": ["Ubuntu 22.04", "Nginx reverse proxy", "SSL certificates"]
    },
    "web-server-2": {
      "shape": "server",
      "name": "Web Server 2",
      "ip": "10.1.0.21",
      "role": "DMZ",
      "tags": ["Web", "Nginx", "DMZ"],
      "notes": ["Ubuntu 22.04", "Nginx reverse proxy", "SSL certificates"]
    },
    "web-server-3": {
      "shape": "server",
      "name": "Web Server 3",
      "ip": "10.1.0.22",
      "role": "DMZ",
      "tags": ["Web", "Nginx", "DMZ"],
      "notes": ["Ubuntu 22.04", "Nginx reverse proxy", "SSL certificates"]
    },
    "internal-fw": {
      "shape": "firewall",
      "name": "Internal Firewall",
      "ip": "10.2.0.1",
      "role": "Security",
      "tags": ["Firewall", "FortiGate"],
      "notes": ["FortiGate 600E", "IPS enabled", "App control"]
    },
    "ad-dc-1": {
      "shape": "server",
      "name": "Domain Controller 1",
      "ip": "10.2.1.10",
      "role": "Internal",
      "tags": ["AD", "DNS", "Windows"],
      "notes": ["Windows Server 2022", "Primary DC", "FSMO roles"]
    },
    "ad-dc-2": {
      "shape": "server",
      "name": "Domain Controller 2",
      "ip": "10.2.1.11",
      "role": "Internal",
      "tags": ["AD", "DNS", "Windows"],
      "notes": ["Windows Server 2022", "Secondary DC", "Replica"]
    },
    "file-server": {
      "shape": "database",
      "name": "File Server",
      "ip": "10.2.1.20",
      "role": "Internal",
      "tags": ["Storage", "SMB", "Windows"],
      "notes": ["Windows Server 2022", "50TB storage", "DFS replication"]
    },
    "db-primary": {
      "shape": "database",
      "name": "Database Primary",
      "ip": "10.3.0.10",
      "role": "Data Center",
      "tags": ["Database", "PostgreSQL", "Primary"],
      "notes": ["PostgreSQL 15", "Primary node", "64GB RAM"]
    },
    "db-replica": {
      "shape": "database",
      "name": "Database Replica",
      "ip": "10.3.0.11",
      "role": "Data Center",
      "tags": ["Database", "PostgreSQL", "Replica"],
      "notes": ["PostgreSQL 15", "Read replica", "Streaming replication"]
    },
    "app-server-1": {
      "shape": "server",
      "name": "App Server 1",
      "ip": "10.3.0.20",
      "role": "Data Center",
      "tags": ["Application", "Java", "Production"],
      "notes": ["RHEL 9", "Tomcat cluster", "32GB RAM"]
    },
    "app-server-2": {
      "shape": "server",
      "name": "App Server 2",
      "ip": "10.3.0.21",
      "role": "Data Center",
      "tags": ["Application", "Java", "Production"],
      "notes": ["RHEL 9", "Tomcat cluster", "32GB RAM"]
    },
    "app-server-3": {
      "shape": "server",
      "name": "App Server 3",
      "ip": "10.3.0.22",
      "role": "Data Center",
      "tags": ["Application", "Java", "Production"],
      "notes": ["RHEL 9", "Tomcat cluster", "32GB RAM"]
    },
    "k8s-master-1": {
      "shape": "server",
      "name": "K8s Master 1",
      "ip": "10.3.1.10",
      "role": "Data Center",
      "tags": ["Kubernetes", "Master", "Container"],
      "notes": ["K8s 1.28", "Control plane", "etcd"]
    },
    "k8s-master-2": {
      "shape": "server",
      "name": "K8s Master 2",
      "ip": "10.3.1.11",
      "role": "Data Center",
      "tags": ["Kubernetes", "Master", "Container"],
      "notes": ["K8s 1.28", "Control plane", "etcd"]
    },
    "k8s-worker-1": {
      "shape": "server",
      "name": "K8s Worker 1",
      "ip": "10.3.1.20",
      "role": "Data Center",
      "tags": ["Kubernetes", "Worker", "Container"],
      "notes": ["64GB RAM", "24 cores", "NVMe storage"]
    },
    "k8s-worker-2": {
      "shape": "server",
      "name": "K8s Worker 2",
      "ip": "10.3.1.21",
      "role": "Data Center",
      "tags": ["Kubernetes", "Worker", "Container"],
      "notes": ["64GB RAM", "24 cores", "NVMe storage"]
    },
    "k8s-worker-3": {
      "shape": "server",
      "name": "K8s Worker 3",
      "ip": "10.3.1.22",
      "role": "Data Center",
      "tags": ["Kubernetes", "Worker", "Container"],
      "notes": ["64GB RAM", "24 cores", "NVMe storage"]
    },
    "backup-server": {
      "shape": "database",
      "name": "Backup Server",
      "ip": "10.4.0.10",
      "role": "Management",
      "tags": ["Backup", "Veeam"],
      "notes": ["Veeam B&R", "100TB capacity", "Offsite replication"]
    },
    "monitoring": {
      "shape": "server",
      "name": "Monitoring",
      "ip": "10.4.0.20",
      "role": "Management",
      "tags": ["Monitoring", "Grafana", "Prometheus"],
      "notes": ["Prometheus + Grafana", "500+ endpoints", "Alert manager"]
    },
    "vpn-gateway": {
      "shape": "firewall",
      "name": "VPN Gateway",
      "ip": "10.0.1.10",
      "role": "Security",
      "tags": ["VPN", "SSL-VPN", "Remote"],
      "notes": ["Cisco AnyConnect", "MFA enabled", "Split tunnel"]
    },
    "san-storage": {
      "shape": "database",
      "name": "SAN Storage",
      "ip": "10.5.0.10",
      "role": "Storage",
      "tags": ["SAN", "iSCSI", "FC"],
      "notes": ["Pure Storage", "200TB usable", "All-flash array"]
    },
    "branch-router": {
      "shape": "router",
      "name": "Branch Office Router",
      "ip": "10.100.0.1",
      "role": "Branch",
      "tags": ["Remote", "SD-WAN"],
      "notes": ["Site-to-site VPN", "SD-WAN enabled", "MPLS backup"]
    },
    "branch-switch": {
      "shape": "switch",
      "name": "Branch Switch",
      "ip": "10.100.0.10",
      "role": "Branch",
      "tags": ["Switch", "Remote"],
      "notes": ["24-port managed", "PoE+", "Local VLAN routing"]
    },
    "workstation-vlan": {
      "shape": "pc",
      "name": "User Workstations",
      "ip": "10.2.10.0/24",
      "role": "Internal",
      "tags": ["Users", "VLAN10"],
      "notes": ["250+ endpoints", "802.1X auth", "Windows 11"]
    },
    "guest-wifi-controller": {
      "shape": "router",
      "name": "WiFi Controller",
      "ip": "10.10.0.1",
      "role": "Guest",
      "tags": ["WiFi", "Controller"],
      "notes": ["Cisco WLC", "50+ APs", "Captive portal"]
    },
    "remote-workers": {
      "shape": "laptop",
      "name": "Remote Workers",
      "ip": "VPN Pool",
      "role": "Remote",
      "tags": ["VPN", "Remote"],
      "notes": ["200+ users", "SSL VPN", "MFA required"]
    },
    "mail-server": {
      "shape": "server",
      "name": "Mail Server",
      "ip": "10.2.2.10",
      "role": "Internal",
      "tags": ["Email", "Exchange"],
      "notes": ["Exchange 2019", "500 mailboxes", "Hybrid O365"]
    }
  },
  "edgeData": {
    "list": [
      {"id": "e1", "from": "internet", "to": "edge-firewall", "width": 8, "color": "#ef4444", "direction": "both", "type": "wan", "notes": ["10 Gbps ISP"]},
      {"id": "e2", "from": "edge-firewall", "to": "core-router-1", "width": 7, "color": "#f97316", "direction": "both", "type": "core", "notes": ["10 Gbps trunk"]},
      {"id": "e3", "from": "edge-firewall", "to": "core-router-2", "width": 7, "color": "#f97316", "direction": "both", "type": "core", "notes": ["10 Gbps trunk"]},
      {"id": "e4", "from": "core-router-1", "to": "core-router-2", "width": 6, "color": "#3b82f6", "direction": "both", "type": "core", "notes": ["HSRP/VRRP"]},
      {"id": "e5", "from": "core-router-1", "to": "core-switch-1", "width": 6, "color": "#3b82f6", "direction": "both", "type": "core", "notes": ["40 Gbps"]},
      {"id": "e6", "from": "core-router-2", "to": "core-switch-2", "width": 6, "color": "#3b82f6", "direction": "both", "type": "core", "notes": ["40 Gbps"]},
      {"id": "e7", "from": "core-switch-1", "to": "core-switch-2", "width": 5, "color": "#3b82f6", "direction": "both", "type": "core", "notes": ["VSS link"]},
      {"id": "e8", "from": "core-router-1", "to": "load-balancer", "width": 5, "color": "#8b5cf6", "direction": "both", "type": "dmz", "notes": ["DMZ VLAN"]},
      {"id": "e9", "from": "load-balancer", "to": "web-server-1", "width": 4, "color": "#8b5cf6", "direction": "both", "type": "dmz", "notes": []},
      {"id": "e10", "from": "load-balancer", "to": "web-server-2", "width": 4, "color": "#8b5cf6", "direction": "both", "type": "dmz", "notes": []},
      {"id": "e11", "from": "load-balancer", "to": "web-server-3", "width": 4, "color": "#8b5cf6", "direction": "both", "type": "dmz", "notes": []},
      {"id": "e12", "from": "core-switch-1", "to": "internal-fw", "width": 6, "color": "#10b981", "direction": "both", "type": "internal", "notes": ["Internal zone"]},
      {"id": "e13", "from": "core-switch-2", "to": "internal-fw", "width": 6, "color": "#10b981", "direction": "both", "type": "internal", "notes": ["Internal zone"]},
      {"id": "e14", "from": "internal-fw", "to": "ad-dc-1", "width": 4, "color": "#10b981", "direction": "both", "type": "internal", "notes": []},
      {"id": "e15", "from": "internal-fw", "to": "ad-dc-2", "width": 4, "color": "#10b981", "direction": "both", "type": "internal", "notes": []},
      {"id": "e16", "from": "internal-fw", "to": "file-server", "width": 4, "color": "#10b981", "direction": "both", "type": "internal", "notes": []},
      {"id": "e17", "from": "internal-fw", "to": "workstation-vlan", "width": 5, "color": "#10b981", "direction": "both", "type": "internal", "notes": ["User VLAN"]},
      {"id": "e18", "from": "internal-fw", "to": "mail-server", "width": 4, "color": "#10b981", "direction": "both", "type": "internal", "notes": []},
      {"id": "e19", "from": "core-switch-1", "to": "db-primary", "width": 5, "color": "#06b6d4", "direction": "both", "type": "datacenter", "notes": ["Data Center"]},
      {"id": "e20", "from": "db-primary", "to": "db-replica", "width": 4, "color": "#14b8a6", "direction": "forward", "type": "replication", "notes": ["DB replication"]},
      {"id": "e21", "from": "core-switch-1", "to": "app-server-1", "width": 4, "color": "#06b6d4", "direction": "both", "type": "datacenter", "notes": []},
      {"id": "e22", "from": "core-switch-1", "to": "app-server-2", "width": 4, "color": "#06b6d4", "direction": "both", "type": "datacenter", "notes": []},
      {"id": "e23", "from": "core-switch-1", "to": "app-server-3", "width": 4, "color": "#06b6d4", "direction": "both", "type": "datacenter", "notes": []},
      {"id": "e24", "from": "app-server-1", "to": "db-primary", "width": 3, "color": "#64748b", "direction": "both", "type": "datacenter", "notes": []},
      {"id": "e25", "from": "app-server-2", "to": "db-primary", "width": 3, "color": "#64748b", "direction": "both", "type": "datacenter", "notes": []},
      {"id": "e26", "from": "app-server-3", "to": "db-primary", "width": 3, "color": "#64748b", "direction": "both", "type": "datacenter", "notes": []},
      {"id": "e27", "from": "core-switch-2", "to": "k8s-master-1", "width": 4, "color": "#ec4899", "direction": "both", "type": "k8s", "notes": ["K8s cluster"]},
      {"id": "e28", "from": "core-switch-2", "to": "k8s-master-2", "width": 4, "color": "#ec4899", "direction": "both", "type": "k8s", "notes": ["K8s cluster"]},
      {"id": "e29", "from": "k8s-master-1", "to": "k8s-worker-1", "width": 3, "color": "#ec4899", "direction": "both", "type": "k8s", "notes": []},
      {"id": "e30", "from": "k8s-master-1", "to": "k8s-worker-2", "width": 3, "color": "#ec4899", "direction": "both", "type": "k8s", "notes": []},
      {"id": "e31", "from": "k8s-master-2", "to": "k8s-worker-3", "width": 3, "color": "#ec4899", "direction": "both", "type": "k8s", "notes": []},
      {"id": "e32", "from": "core-switch-2", "to": "backup-server", "width": 4, "color": "#f59e0b", "direction": "both", "type": "mgmt", "notes": ["Mgmt network"]},
      {"id": "e33", "from": "core-switch-2", "to": "monitoring", "width": 3, "color": "#f59e0b", "direction": "both", "type": "mgmt", "notes": ["Mgmt network"]},
      {"id": "e34", "from": "core-router-1", "to": "vpn-gateway", "width": 4, "color": "#a855f7", "direction": "both", "type": "vpn", "notes": ["Remote access"]},
      {"id": "e35", "from": "vpn-gateway", "to": "remote-workers", "width": 3, "color": "#a855f7", "direction": "both", "type": "vpn", "notes": ["SSL VPN"]},
      {"id": "e36", "from": "core-switch-1", "to": "san-storage", "width": 5, "color": "#0ea5e9", "direction": "both", "type": "storage", "notes": ["Storage network"]},
      {"id": "e37", "from": "san-storage", "to": "db-primary", "width": 3, "color": "#0ea5e9", "direction": "both", "type": "storage", "notes": ["iSCSI LUNs"]},
      {"id": "e38", "from": "san-storage", "to": "app-server-1", "width": 2, "color": "#0ea5e9", "direction": "both", "type": "storage", "notes": []},
      {"id": "e39", "from": "edge-firewall", "to": "branch-router", "width": 4, "color": "#84cc16", "direction": "both", "type": "branch", "notes": ["Site-to-site VPN"]},
      {"id": "e40", "from": "branch-router", "to": "branch-switch", "width": 3, "color": "#84cc16", "direction": "both", "type": "branch", "notes": []},
      {"id": "e41", "from": "core-router-2", "to": "guest-wifi-controller", "width": 3, "color": "#fbbf24", "direction": "both", "type": "guest", "notes": ["Guest VLAN"]}
    ]
  },
  "edgeLegend": {
    "#ef4444": "WAN / Internet (10 Gbps)",
    "#f97316": "Core Layer (10-40 Gbps)",
    "#3b82f6": "Core Switching & HSRP",
    "#8b5cf6": "DMZ Network",
    "#10b981": "Internal Corporate Network",
    "#06b6d4": "Data Center / Application Tier",
    "#14b8a6": "Database Replication",
    "#64748b": "App-to-DB Connections",
    "#ec4899": "Kubernetes Cluster",
    "#f59e0b": "Management Network",
    "#a855f7": "VPN / Remote Access",
    "#0ea5e9": "Storage Area Network (SAN)",
    "#84cc16": "Branch Office WAN",
    "#fbbf24": "Guest WiFi Network"
  },
  "nodePositions": {
    "internet": {"x": 600, "y": 80},
    "edge-firewall": {"x": 600, "y": 250},
    "core-router-1": {"x": 400, "y": 420},
    "core-router-2": {"x": 800, "y": 420},
    "core-switch-1": {"x": 400, "y": 600},
    "core-switch-2": {"x": 800, "y": 600},
    "load-balancer": {"x": 200, "y": 500},
    "web-server-1": {"x": 80, "y": 650},
    "web-server-2": {"x": 200, "y": 700},
    "web-server-3": {"x": 320, "y": 650},
    "internal-fw": {"x": 600, "y": 780},
    "ad-dc-1": {"x": 500, "y": 950},
    "ad-dc-2": {"x": 620, "y": 950},
    "file-server": {"x": 740, "y": 950},
    "mail-server": {"x": 860, "y": 950},
    "workstation-vlan": {"x": 980, "y": 950},
    "db-primary": {"x": 200, "y": 850},
    "db-replica": {"x": 100, "y": 1000},
    "app-server-1": {"x": 200, "y": 1050},
    "app-server-2": {"x": 320, "y": 1050},
    "app-server-3": {"x": 440, "y": 1050},
    "k8s-master-1": {"x": 900, "y": 700},
    "k8s-master-2": {"x": 1020, "y": 700},
    "k8s-worker-1": {"x": 850, "y": 850},
    "k8s-worker-2": {"x": 970, "y": 850},
    "k8s-worker-3": {"x": 1090, "y": 850},
    "backup-server": {"x": 1050, "y": 600},
    "monitoring": {"x": 1150, "y": 700},
    "vpn-gateway": {"x": 350, "y": 250},
    "remote-workers": {"x": 180, "y": 120},
    "san-storage": {"x": 100, "y": 750},
    "branch-router": {"x": 1000, "y": 250},
    "branch-switch": {"x": 1120, "y": 380},
    "guest-wifi-controller": {"x": 1050, "y": 480}
  },
  "nodeSizes": {
    "internet": 55,
    "edge-firewall": 70,
    "core-router-1": 65,
    "core-router-2": 65,
    "core-switch-1": 60,
    "core-switch-2": 60,
    "load-balancer": 55,
    "web-server-1": 45,
    "web-server-2": 45,
    "web-server-3": 45,
    "internal-fw": 60,
    "ad-dc-1": 50,
    "ad-dc-2": 50,
    "file-server": 50,
    "db-primary": 55,
    "db-replica": 50,
    "app-server-1": 45,
    "app-server-2": 45,
    "app-server-3": 45,
    "k8s-master-1": 50,
    "k8s-master-2": 50,
    "k8s-worker-1": 45,
    "k8s-worker-2": 45,
    "k8s-worker-3": 45,
    "backup-server": 50,
    "monitoring": 45,
    "vpn-gateway": 50,
    "san-storage": 55,
    "branch-router": 50,
    "branch-switch": 45,
    "workstation-vlan": 50,
    "guest-wifi-controller": 45,
    "remote-workers": 45,
    "mail-server": 45
  },
  "nodeStyles": {},
  "page": {
    "title": "Corporate Network Infrastructure",
    "background": "#d4d7dd",
    "topbarBg": "#1081ea",
    "topbarBorder": "#010d28",
    "panel": "#002970",
    "panelAlt": "#0e1c34",
    "accent": "#58dfd2",
    "danger": "#271111",
    "textMain": "#e2e7ee",
    "textSoft": "#7c96bb",
    "topbarHeight": 100,
    "sidebarWidth": 600,
    "sidebarCollapsed": false
  },
  "canvas": {
    "zoom": 1,
    "panX": 0,
    "panY": 0
  }
}</script>

  <script>
    const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent);
    let currentNodeId = "host";
    let currentEdgeId = null;
    let currentStyleScope = "all";
    let NODE_DATA = {}; 
    let EDGE_DATA = { list: [] };
    let EDGE_LEGEND = {};
    let savedPositions = {};
    let savedSizes = {};
    let savedStyles = {};

    const DEFAULT_PAGE_STATE = {
      title: "Network Topology",
      background: "", 
      topbarBg: "rgba(9, 12, 20, 0.9)",
      topbarBorder: "#1f2533",
      panel: "#0b0e13",
      panelAlt: "#10141b",
      accent: "#4fd1c5",
      danger: "#f56565",
      textMain: "#e2e8f0",
      textSoft: "#94a3b8",
      topbarHeight: 52,
      sidebarWidth: 350,
      mobileFooterHeight: 40, 
      sidebarCollapsed: false
    };

    let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);

    const CANVAS_WIDTH = 4000;
    const CANVAS_HEIGHT = 3000;
    const CANVAS_PADDING = 100; 

    let canvasState = {
      zoom: 1,
      panX: 0,
      panY: 0,
      minZoom: 0.25,  
      maxZoom: 4,
      isPanning: false,
      panStartX: 0,
      panStartY: 0,
      spacePressed: false
    };

    function getViewBox() {
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight
      };
    }

    function updateViewBox() {
      const svg = document.getElementById("map");
      const vb = getViewBox();
      svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);

      const zoomLevel = document.getElementById("zoom-level");
      if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
      }

      updateMinimap();
    }

    function updateMinimap() {
      const minimapViewport = document.getElementById("minimap-viewport");
      const minimapSvg = document.getElementById("minimap");
      if (!minimapViewport || !minimapSvg) return;

      const vb = getViewBox();
      minimapViewport.setAttribute("x", vb.x);
      minimapViewport.setAttribute("y", vb.y);
      minimapViewport.setAttribute("width", vb.width);
      minimapViewport.setAttribute("height", vb.height);

      const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
      minimapNodes.forEach(n => n.remove());
      const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
      minimapEdges.forEach(e => e.remove());

      EDGE_DATA.list.forEach(edge => {
        if (edge.type === "custom") return;
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
      });

      Object.entries(savedPositions).forEach(([id, pos]) => {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
      });
    }

    function zoomTo(newZoom, centerX, centerY) {
      const oldZoom = canvasState.zoom;
      newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom));

      if (centerX !== undefined && centerY !== undefined) {

        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;

        const pointX = canvasState.panX + (centerX * oldWidth);
        const pointY = canvasState.panY + (centerY * oldHeight);

        canvasState.panX = pointX - (centerX * newWidth);
        canvasState.panY = pointY - (centerY * newHeight);
      }

      canvasState.zoom = newZoom;
      constrainPan();
      updateViewBox();
    }

    function constrainPan() {
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;

      const minVisiblePortion = 0.1;
      const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
      const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
      const minPanX = -viewWidth * (1 - minVisiblePortion);
      const minPanY = -viewHeight * (1 - minVisiblePortion);

      canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX));
      canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY));
    }

    function fitToContent() {

      const positions = Object.values(savedPositions);
      if (positions.length === 0) {
        resetView();
        return;
      }

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      positions.forEach(pos => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
      });

      const contentWidth = maxX - minX + 200;
      const contentHeight = maxY - minY + 200;

      const viewport = document.getElementById("canvas-viewport");
      const vpRect = viewport.getBoundingClientRect();
      const aspectRatio = vpRect.width / vpRect.height;
      const contentAspect = contentWidth / contentHeight;

      let newZoom;
      if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
      } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
      }

      newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));

      const viewWidth = CANVAS_WIDTH / newZoom;
      const viewHeight = CANVAS_HEIGHT / newZoom;

      canvasState.zoom = newZoom;
      canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
      canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;

      constrainPan();
      updateViewBox();
    }

    function resetView() {
      canvasState.zoom = 1;
      canvasState.panX = 0;
      canvasState.panY = 0;
      updateViewBox();
    }

    function wieldThePower() {
      const root = document.documentElement;

      root.style.setProperty("--panel", PAGE_STATE.panel);
      root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
      root.style.setProperty("--accent", PAGE_STATE.accent);
      root.style.setProperty("--danger", PAGE_STATE.danger);
      root.style.setProperty("--text-main", PAGE_STATE.textMain);
      root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
      root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
      root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);

      const topbarHeight = PAGE_STATE.topbarHeight || 52;
      const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
      const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
      root.style.setProperty("--topbar-height", topbarHeight + "px");
      root.style.setProperty("--sidebar-width", sidebarWidth + "px");
      root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh");

      const topbarHeightInput = document.getElementById("topbar-height");
      const topbarHeightVal = document.getElementById("topbar-height-val");
      const sidebarWidthInput = document.getElementById("sidebar-width");
      const sidebarWidthVal = document.getElementById("sidebar-width-val");
      const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
      const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");

      if (topbarHeightInput) topbarHeightInput.value = topbarHeight;
      if (topbarHeightVal) topbarHeightVal.textContent = topbarHeight + "px";
      if (sidebarWidthInput) sidebarWidthInput.value = sidebarWidth;
      if (sidebarWidthVal) sidebarWidthVal.textContent = sidebarWidth + "px";
      if (mobileFooterHeightInput) mobileFooterHeightInput.value = mobileFooterHeight;
      if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = mobileFooterHeight + "%";

      const mainEl = document.querySelector("main");
      const detailsPanel = document.getElementById("details-panel");
      const sidebarToggle = document.getElementById("sidebar-toggle");

      if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
          sidebarToggle.classList.add("collapsed");
          sidebarToggle.textContent = "‚ñ∂";
        }
      } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
          sidebarToggle.classList.remove("collapsed");
          sidebarToggle.textContent = "‚óÄ";
        }
      }

      if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
      } else {
        document.body.style.background = "radial-gradient(circle at top, #1e2532 0, #050608 70%)";
      }

      document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
      const titleEl = document.getElementById("page-title");
      if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
      }
    }

    (async function awakeTheImmortal() {
      let initialState = {};
      let decryptionCancelled = false;
      const stateEl = document.getElementById("topology-state");
      if (stateEl && stateEl.textContent.trim()) {
        try {
          let stateText = stateEl.textContent.trim();

          if (isEncrypted(stateText)) {
            let decrypted = false;
            let attempts = 0;
            const maxAttempts = 3;

            while (!decrypted && attempts < maxAttempts) {
              const password = prompt('This file is encrypted. Enter password to decrypt:\n(Attempt ' + (attempts + 1) + ' of ' + maxAttempts + ')');

              if (!password) {
                alert('Decryption cancelled. The file will not be loaded.');
                decryptionCancelled = true;
                break;
              }

              try {
                stateText = await decryptData(stateText, password);
                decrypted = true;
              } catch (e) {
                attempts++;
                if (attempts < maxAttempts) {
                  alert('Incorrect password. Please try again.');
                } else {
                  alert('Maximum attempts reached. The file will not be loaded.');
                  decryptionCancelled = true;
                }
              }
            }

            if (!decrypted) {
              stateText = '{}';
            }
          }

          initialState = JSON.parse(stateText);
        } catch (e) {
          console.error('Failed to load state:', e);
          initialState = {};
        }
      }

      if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
      } else {

        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;

        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
          list: []
        };

        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
      }

      if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page);
      }

      if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
      }

      wieldThePower();

      forgeTheTopology();
      updateViewBox();

      const initialNodes = Object.keys(NODE_DATA);
      if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0]);
      } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
      }
    })();

    function saveEdgeData() {

    }

    function saveEdgeLegend() {

    }

    function getBreakpointKey() {
      const w = window.innerWidth;
      if (w <= 380) return "fold";
      if (w <= 768) return "mobile";
      if (w <= 1024) return "tablet";
      return "desktop";
    }

    function resolveStylesEntry(styleEntry) {
      if (!styleEntry) return {};

      if (
        styleEntry.circleColor ||
        styleEntry.titleColor ||
        styleEntry.titleFont ||
        styleEntry.titleSize ||
        styleEntry.subColor ||
        styleEntry.subFont ||
        styleEntry.subSize
      ) {
        return styleEntry;
      }

      const bp = getBreakpointKey();
      const base = styleEntry.all || {};
      const bpStyles = styleEntry[bp] || {};
      return Object.assign({}, base, bpStyles);
    }

    function resolveStylesForNode(id) {
      const styleEntry = savedStyles[id];
      if (!styleEntry) return {};
      return resolveStylesEntry(styleEntry);
    }

    function ensureStyleEntry(id) {
      if (!savedStyles[id]) savedStyles[id] = {};
      const entry = savedStyles[id];
      const flatProps = [
        "circleColor","titleColor","titleFont","titleSize",
        "subColor","subFont","subSize"
      ];
      const isFlat = flatProps.some(p => Object.prototype.hasOwnProperty.call(entry, p));
      if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach(p => {
          if (entry[p] !== undefined) {
            all[p] = entry[p];
            delete entry[p];
          }
        });
        entry.all = all;
      }
      return entry;
    }

    function getDefaultSize() {
      if (window.innerWidth <= 380) return 120;
      if (window.innerWidth <= 768) return 140;
      if (window.innerWidth <= 1024) return 70;
      return 55;
    }

    function createShapeElement(shape, size) {
      const ns = "http://www.w3.org/2000/svg";

      if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
      }

      if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
      }

      if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
      }

      if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w/2},${h/2} ${-w/2},${h/2}`);
        return p;
      }

      if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
          [0, -s],
          [s * 0.86, -s * 0.5],
          [s * 0.86, s * 0.5],
          [0, s],
          [-s * 0.86, s * 0.5],
          [-s * 0.86, -s * 0.5]
        ].map(pt => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
      }

      if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
          const a = (Math.PI / 4) * i + Math.PI / 8;
          ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map(pt => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
      }

      if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
          const a = (Math.PI / 5) * i - Math.PI / 2;
          const r = i % 2 === 0 ? outer : inner;
          pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
      }

      if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
      }

      if (shape === "server") {

        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);

        for (let i = 0; i < 3; i++) {
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
          line.setAttribute("y1", -size * 0.3);
          line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
          line.setAttribute("y2", size * 0.3);
          line.style.stroke = "currentColor";
          line.style.strokeWidth = "2";
          line.style.opacity = "0.5";
          g.appendChild(line);
        }

        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
      }

      if (shape === "pc" || shape === "desktop") {

        const g = document.createElementNS(ns, "g");

        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);

        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);

        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);

        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
      }

      if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");

        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);

        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);

        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
      }

      if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");

        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);

        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);

        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
      }

      if (shape === "router") {
        const g = document.createElementNS(ns, "g");

        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);

        for (let i = -1; i <= 1; i++) {
          const ant = document.createElementNS(ns, "rect");
          ant.setAttribute("x", i * size * 0.6 - size * 0.05);
          ant.setAttribute("y", -size * 0.9);
          ant.setAttribute("width", size * 0.1);
          ant.setAttribute("height", size * 0.6);
          ant.setAttribute("rx", 2);
          g.appendChild(ant);

          const tip = document.createElementNS(ns, "circle");
          tip.setAttribute("cx", i * size * 0.6);
          tip.setAttribute("cy", -size * 0.95);
          tip.setAttribute("r", size * 0.08);
          g.appendChild(tip);
        }

        for (let i = 0; i < 4; i++) {
          const led = document.createElementNS(ns, "circle");
          led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
          led.setAttribute("cy", size * 0.1);
          led.setAttribute("r", size * 0.06);
          led.style.fill = i < 2 ? "#4ade80" : "#facc15";
          g.appendChild(led);
        }
        return g;
      }

      if (shape === "switch") {
        const g = document.createElementNS(ns, "g");

        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);

        for (let i = 0; i < 8; i++) {
          const port = document.createElementNS(ns, "rect");
          port.setAttribute("x", -size * 1.2 + i * size * 0.32);
          port.setAttribute("y", -size * 0.15);
          port.setAttribute("width", size * 0.22);
          port.setAttribute("height", size * 0.3);
          port.setAttribute("rx", 1);
          port.style.fill = "#1e293b";
          g.appendChild(port);
        }
        return g;
      }

      if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");

        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);

        for (let row = 0; row < 3; row++) {
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", -size * 0.85);
          line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
          line.setAttribute("x2", size * 0.85);
          line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
          line.style.stroke = "#475569";
          line.style.strokeWidth = "2";
          g.appendChild(line);
        }

        for (let row = 0; row < 4; row++) {
          const offset = row % 2 === 0 ? 0 : size * 0.35;
          for (let col = 0; col < 3; col++) {
            const line = document.createElementNS(ns, "line");
            const x = -size * 0.5 + col * size * 0.7 + offset;
            if (x > -size * 0.85 && x < size * 0.85) {
              line.setAttribute("x1", x);
              line.setAttribute("y1", -size * 0.8 + row * size * 0.45);
              line.setAttribute("x2", x);
              line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45);
              line.style.stroke = "#475569";
              line.style.strokeWidth = "2";
              g.appendChild(line);
            }
          }
        }
        return g;
      }

      if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;

        p.setAttribute("d", `
          M ${-s*0.8} ${s*0.2}
          Q ${-s*1.1} ${s*0.2} ${-s*1.1} ${-s*0.1}
          Q ${-s*1.1} ${-s*0.5} ${-s*0.7} ${-s*0.5}
          Q ${-s*0.7} ${-s*0.9} ${-s*0.2} ${-s*0.9}
          Q ${s*0.1} ${-s*1.1} ${s*0.5} ${-s*0.8}
          Q ${s*1} ${-s*0.8} ${s*1.1} ${-s*0.3}
          Q ${s*1.3} ${-s*0.1} ${s*1.1} ${s*0.2}
          Q ${s*1.1} ${s*0.5} ${s*0.7} ${s*0.5}
          L ${-s*0.5} ${s*0.5}
          Q ${-s*0.9} ${s*0.5} ${-s*0.9} ${s*0.2}
          Z
        `);
        return p;
      }

      if (shape === "database") {
        const g = document.createElementNS(ns, "g");

        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);

        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);

        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);

        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
      }

      if (shape === "printer") {
        const g = document.createElementNS(ns, "g");

        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);

        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);

        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);

        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
      }

      const c = document.createElementNS(ns, "circle");
      c.setAttribute("r", size);
      return c;
    }

    function createNodeShape(id, size) {
      const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
      const shapeEl = createShapeElement(shapeType, size);
      shapeEl.classList.add("node-circle");
      const styles = resolveStylesForNode(id);
      if (styles.circleColor) {
        shapeEl.style.stroke = styles.circleColor;
      }
      return shapeEl;
    }



    function forgeTheLegend() {
      const container = document.getElementById("edge-legend");
      if (!container) return;
      container.innerHTML = "";

      const title = document.createElement("div");
      title.className = "legend-title";
      title.textContent = "Line Legend";
      container.appendChild(title);

      const colors = [...new Set(EDGE_DATA.list.map(e => e.color).filter(Boolean))];
      if (colors.length === 0) {
        container.style.display = "none";
        return;
      }

      colors.forEach(color => {
        if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
        }

        const item = document.createElement("div");
        item.className = "legend-item";

        item.addEventListener("mousedown", (e) => {
          e.stopPropagation();
        });

        item.addEventListener("click", (e) => {
          e.stopPropagation();
        });

        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;

        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        label.contentEditable = true;

        label.addEventListener("mousedown", (e) => {
          e.stopPropagation();
        });

        label.addEventListener("click", (e) => {
          e.stopPropagation();
        });

        label.addEventListener("touchstart", (e) => {
          e.stopPropagation();
        });

        label.addEventListener("focus", () => {
          label.classList.add("editing");
        });

        label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
          saveEdgeLegend();
        });

        label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            label.blur();
          }
        });

        item.append(swatch, label);
        container.appendChild(item);
      });

      container.style.display = "flex";
    }

    function forgeTheTopology() {

      if (!NODE_DATA || !EDGE_DATA) {
        console.warn('forgeTheTopology called before data initialized');
        return;
      }

      const svg = document.getElementById("map");
      svg.innerHTML = "";

      const ns = "http://www.w3.org/2000/svg";

      const defs = document.createElementNS(ns, "defs");

      const markerForward = document.createElementNS(ns, "marker");
      markerForward.id = "arrow-forward";
      markerForward.setAttribute("markerWidth", "10");
      markerForward.setAttribute("markerHeight", "10");
      markerForward.setAttribute("refX", "9");
      markerForward.setAttribute("refY", "3");
      markerForward.setAttribute("orient", "auto");
      markerForward.setAttribute("markerUnits", "strokeWidth");
      const pathForward = document.createElementNS(ns, "path");
      pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
      pathForward.setAttribute("fill", "context-stroke");
      markerForward.appendChild(pathForward);
      defs.appendChild(markerForward);

      const markerBackward = document.createElementNS(ns, "marker");
      markerBackward.id = "arrow-backward";
      markerBackward.setAttribute("markerWidth", "10");
      markerBackward.setAttribute("markerHeight", "10");
      markerBackward.setAttribute("refX", "0");
      markerBackward.setAttribute("refY", "3");
      markerBackward.setAttribute("orient", "auto");
      markerBackward.setAttribute("markerUnits", "strokeWidth");
      const pathBackward = document.createElementNS(ns, "path");
      pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
      pathBackward.setAttribute("fill", "context-stroke");
      markerBackward.appendChild(pathBackward);
      defs.appendChild(markerBackward);

      svg.appendChild(defs);

      const boundary = document.createElementNS(ns, "rect");
      boundary.setAttribute("x", CANVAS_PADDING);
      boundary.setAttribute("y", CANVAS_PADDING);
      boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
      boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
      boundary.setAttribute("fill", "none");
      boundary.setAttribute("stroke", "rgba(71, 85, 105, 0.3)");
      boundary.setAttribute("stroke-width", "2");
      boundary.setAttribute("stroke-dasharray", "10 5");
      boundary.setAttribute("rx", "8");
      svg.appendChild(boundary);

      const centerX = CANVAS_WIDTH / 2;
      const centerY = CANVAS_HEIGHT / 2;

      let positions = {};

      Object.keys(NODE_DATA).forEach(id => {
        positions[id] = savedPositions[id] || { x: centerX, y: centerY };
      });

      if (Object.keys(savedPositions).length === 0) {

        const nodeIds = Object.keys(NODE_DATA);
        const baseY = centerY - 300;

        if (nodeIds.length > 0) {

          positions[nodeIds[0]] = { x: centerX, y: baseY };

          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;

          remaining.forEach((id, i) => {
            const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
            positions[id] = {
              x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
              y: baseY + 200 + Math.sin(angle) * radius * 0.8 + (i * 80)
            };
          });
        }
      }

      Object.keys(positions).forEach(id => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;

        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x));
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y));

        positions[id] = { x: pos.x, y: pos.y };
        savedPositions[id] = { x: pos.x, y: pos.y };
      });

      const edgePairCount = {};
      const edgePairIndex = {};
      EDGE_DATA.list.forEach(edge => {
        if (edge.type === "custom") return;

        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
      });

      EDGE_DATA.list.forEach(edge => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
      });

      EDGE_DATA.list.forEach(edge => {

        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");

          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
            poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
            poly.style.strokeDasharray = "2,4";
          } else {
            poly.style.strokeDasharray = "none";
          }

          const direction = edge.direction || "none";
          if (direction === "forward") {
            poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
            poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
            poly.setAttribute("marker-start", "url(#arrow-backward)");
            poly.setAttribute("marker-end", "url(#arrow-forward)");
          }

          const ptsStr = edge.points.map(p => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);

          poly.addEventListener("click", (e) => {
            e.stopPropagation();
            selectTheConnection(edge.id);
          });

          svg.appendChild(poly);
          return;
        }

        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;

        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;

        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;

        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;

        let offsetAmount = 0;
        if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;

        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;

        path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
        });

        svg.appendChild(path);
      });

      Object.entries(positions).forEach(([id,pos]) => {
        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform",`translate(${pos.x},${pos.y})`);

        let r = savedSizes[id] || 55;
        if (!savedSizes[id]) {
          if (window.innerWidth <= 380) r = 120;
          else if (window.innerWidth <= 768) r = 140;
          else if (window.innerWidth <= 1024) r = 70;
        }

        const styles = resolveStylesForNode(id);
        const shapeEl = createNodeShape(id, r);

        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;

        const label = document.createElementNS("http://www.w3.org/2000/svg","text");
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r*0.28 + titleOffsetY);
        const labelFontSize = (styles.titleSize || (r * 0.33));
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
        if (styles.titleColor) label.style.fill = styles.titleColor;
        if (styles.titleFont) label.style.fontFamily = styles.titleFont;
        label.style.cursor = "pointer";
        label.addEventListener("click", (e) => {
          e.stopPropagation();
          editNodeName(id);
        });

        const sub = document.createElementNS("http://www.w3.org/2000/svg","text");
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r*0.4 + subOffsetY);
        const subFontSize = (styles.subSize || (r * 0.24));
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
        if (styles.subColor) sub.style.fill = styles.subColor;
        if (styles.subFont) sub.style.fontFamily = styles.subFont;
        sub.style.cursor = "pointer";
        sub.addEventListener("click", (e) => {
          e.stopPropagation();
          editNodeIp(id);
        });

        g.append(shapeEl,label,sub);

        let isDragging = false;
        let startX, startY;

        g.addEventListener("mousedown", (e) => {
          e.preventDefault();
          isDragging = true;

          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          startX = svgP.x - pos.x;
          startY = svgP.y - pos.y;
          g.style.cursor = "grabbing";
          e.stopPropagation();
        });

        const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());

          let newX = svgP.x - startX;
          let newY = svgP.y - startY;

          const nodeSize = savedSizes[id] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));

          pos.x = newX;
          pos.y = newY;
          g.setAttribute("transform",`translate(${pos.x},${pos.y})`);

          positions[id] = { x: pos.x, y: pos.y };
          savedPositions[id] = { x: pos.x, y: pos.y };

          updateMinimap();

          document.querySelectorAll(".edge").forEach(edgeEl => {
            const fromId = edgeEl.dataset.from;
            const toId = edgeEl.dataset.to;

            if (fromId === id || toId === id) {

              const p1 = savedPositions[fromId] || positions[fromId] || { x: 600, y: 350 };
              const p2 = savedPositions[toId] || positions[toId] || { x: 600, y: 350 };

              if (edgeEl.tagName === "line") {
                edgeEl.setAttribute("x1", p1.x);
                edgeEl.setAttribute("y1", p1.y);
                edgeEl.setAttribute("x2", p2.x);
                edgeEl.setAttribute("y2", p2.y);
              } else if (edgeEl.tagName === "path") {

                const edgeId = edgeEl.dataset.edgeId;
                const edge = EDGE_DATA.list.find(e => e.id === edgeId);
                if (edge) {
                  const pairTotal = edge._pairTotal || 1;
                  const pairIndex = edge._pairIndex || 0;

                  const midX = (p1.x + p2.x) / 2;
                  const midY = (p1.y + p2.y) / 2;
                  const dx = p2.x - p1.x;
                  const dy = p2.y - p1.y;
                  const len = Math.sqrt(dx * dx + dy * dy) || 1;
                  const perpX = -dy / len;
                  const perpY = dx / len;

                  let offsetAmount = 0;
                  if (pairTotal > 1) {
                    offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
                  }
                  const ctrlX = midX + perpX * offsetAmount;
                  const ctrlY = midY + perpY * offsetAmount;
                  edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
                }
              }
            }
          });
        };

        const handleMouseUp = () => {
          if (isDragging) {
            isDragging = false;
            g.style.cursor = "grab";
            savedPositions[id] = {x: pos.x, y: pos.y};
          }
        };

        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);

        g.addEventListener("touchstart", (e) => {
          e.preventDefault();
          isDragging = true;

          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          startX = svgP.x - pos.x;
          startY = svgP.y - pos.y;
          e.stopPropagation();
        }, { passive: false });

        const handleTouchMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());

          let newX = svgP.x - startX;
          let newY = svgP.y - startY;

          const nodeSize = savedSizes[id] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));

          pos.x = newX;
          pos.y = newY;
          g.setAttribute("transform",`translate(${pos.x},${pos.y})`);

          positions[id] = { x: pos.x, y: pos.y };
          savedPositions[id] = { x: pos.x, y: pos.y };

          updateMinimap();

          document.querySelectorAll(".edge").forEach(edgeEl => {
            const fromId = edgeEl.dataset.from;
            const toId = edgeEl.dataset.to;

            if (fromId === id || toId === id) {

              const p1 = savedPositions[fromId] || positions[fromId] || { x: 600, y: 350 };
              const p2 = savedPositions[toId] || positions[toId] || { x: 600, y: 350 };

              if (edgeEl.tagName === "line") {
                edgeEl.setAttribute("x1", p1.x);
                edgeEl.setAttribute("y1", p1.y);
                edgeEl.setAttribute("x2", p2.x);
                edgeEl.setAttribute("y2", p2.y);
              } else if (edgeEl.tagName === "path") {

                const edgeId = edgeEl.dataset.edgeId;
                const edge = EDGE_DATA.list.find(e => e.id === edgeId);
                if (edge) {
                  const pairTotal = edge._pairTotal || 1;
                  const pairIndex = edge._pairIndex || 0;

                  const midX = (p1.x + p2.x) / 2;
                  const midY = (p1.y + p2.y) / 2;
                  const dx = p2.x - p1.x;
                  const dy = p2.y - p1.y;
                  const len = Math.sqrt(dx * dx + dy * dy) || 1;
                  const perpX = -dy / len;
                  const perpY = dx / len;

                  let offsetAmount = 0;
                  if (pairTotal > 1) {
                    offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
                  }
                  const ctrlX = midX + perpX * offsetAmount;
                  const ctrlY = midY + perpY * offsetAmount;
                  edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
                }
              }
            }
          });
        };

        const handleTouchEnd = () => {
          if (isDragging) {
            isDragging = false;
            savedPositions[id] = {x: pos.x, y: pos.y};
          }
        };

        document.addEventListener("touchmove", handleTouchMove, { passive: false });
        document.addEventListener("touchend", handleTouchEnd);

        g.style.cursor = "grab";

        g.addEventListener("click",(e) => {
          if (!isDragging) {
            claimTheImmortal(id);
          }
        });

        svg.appendChild(g);
      });

      forgeTheLegend();
      updateMinimap();
    }

    function showEditModal(title, currentValue, onSave) {
      const modal = document.getElementById("edit-modal");
      const input = document.getElementById("modal-input");
      const titleEl = document.getElementById("modal-title");
      const saveBtn = document.getElementById("modal-save");
      const cancelBtn = document.getElementById("modal-cancel");

      titleEl.textContent = title;
      input.value = currentValue;
      modal.classList.add("active");
      input.focus();
      input.select();

      const handleSave = () => {
        if (input.value.trim()) {
          onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
      };

      const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
      };

      const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
      };

      saveBtn.addEventListener("click", handleSave);
      cancelBtn.addEventListener("click", handleCancel);
      input.addEventListener("keypress", handleEnter);

      modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
        }
      });
    }

    function challengeTheImmortal(message, onConfirm) {
      const modal = document.getElementById("confirm-modal");
      const messageEl = document.getElementById("confirm-message");
      const deleteBtn = document.getElementById("confirm-delete");
      const cancelBtn = document.getElementById("confirm-cancel");

      messageEl.textContent = message;
      modal.classList.add("active");

      const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
      };

      const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
      };

      deleteBtn.addEventListener("click", handleConfirm);
      cancelBtn.addEventListener("click", handleCancel);

      modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
        }
      });
    }

    const pageTitleEl = document.getElementById("page-title");
    if (pageTitleEl) {
      pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title, (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
        });
      });
    }

    function editNodeName(id) {
      showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
        }
      });
    }

    function editNodeIp(id) {
      showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
        }
      });
    }

    function claimTheImmortal(id) {
      currentNodeId = id;
      currentEdgeId = null;
      const data = NODE_DATA[id];

      document.querySelectorAll(".node-group").forEach(n => {
        n.classList.toggle("active", n.dataset.nodeId === id);
      });

      document.querySelectorAll(".edge").forEach(e => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
      });

      document.getElementById("node-panel").style.display = "block";
      document.getElementById("edge-panel").style.display = "none";

      const toolbar = document.getElementById("topology-toolbar");
      toolbar.style.display = "flex";

      document.getElementById("node-name").textContent = data.name;
      document.getElementById("node-ip").textContent = data.ip;
      document.getElementById("node-role").textContent = data.role;

      document.getElementById("node-name").onclick = () => editNodeName(id);
      document.getElementById("node-ip").onclick = () => editNodeIp(id);

      const currentSize = savedSizes[id] || getDefaultSize();
      document.getElementById("size-slider").value = currentSize;
      document.getElementById("size-value").textContent = currentSize;

      const styleEntry = savedStyles[id] || {};
      const resolvedStyles = resolveStylesEntry(styleEntry);
      const scopeKey = currentStyleScope || "all";
      const flatProps = ["circleColor","titleColor","titleFont","titleSize","subColor","subFont","subSize"];
      const isFlat = flatProps.some(p => Object.prototype.hasOwnProperty.call(styleEntry, p));
      const scopedStyles = isFlat ? styleEntry : (styleEntry[scopeKey] || {});

      const circleColorInput = document.getElementById("circle-color");
      const titleColorInput = document.getElementById("title-color");
      const titleFontSelect = document.getElementById("title-font");
      const titleSizeInput = document.getElementById("title-size");
      const subColorInput = document.getElementById("sub-color");
      const subFontSelect = document.getElementById("sub-font");
      const subSizeInput = document.getElementById("sub-size");
      const shapeSelect = document.getElementById("shape-select");
      const scopeSelect = document.getElementById("style-scope");

      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || "#1e293b";
      titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || "#e2e8f0";
      titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
      titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
      subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || "#94a3b8";
      subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
      subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
      shapeSelect.value = data.shape || "circle";
      scopeSelect.value = currentStyleScope || "all";

      document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
      document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
      document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
      document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;

      const tagEl = document.getElementById("node-tags");
      tagEl.innerHTML = "";
      data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";

        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
          e.stopPropagation();
          showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
              data.tags[i] = newTag;
              claimTheImmortal(id);
            }
          });
        });

        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ‚úï";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          data.tags.splice(i, 1);
          claimTheImmortal(id);
        });

        b.append(tagText, deleteTag);
        tagEl.append(b);
      });

      const addTagBtn = document.createElement("span");
      addTagBtn.className = "badge";
      addTagBtn.style.cursor = "pointer";
      addTagBtn.style.opacity = "0.6";
      addTagBtn.style.borderStyle = "dashed";
      addTagBtn.textContent = "+ Add";
      addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "", (newTagStr) => {
          if (newTagStr) {

            const newTags = newTagStr.split(",").map(t => t.trim()).filter(t => t);
            newTags.forEach(t => data.tags.push(t));
            claimTheImmortal(id);
          }
        });
      });
      tagEl.append(addTagBtn);

      const notesEl = document.getElementById("node-notes");
      notesEl.innerHTML = "";
      data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";

        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "‚úï";
        deleteBtn.addEventListener("click",(e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?", () => {
            data.notes.splice(i,1);
            claimTheImmortal(id);
          });
        });

        li.append(noteText, deleteBtn);

        noteText.addEventListener("dblclick",() => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
        });

        noteText.addEventListener("blur",() => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          data.notes[i] = noteText.textContent;
        });

        notesEl.append(li);
      });

      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      Object.entries(NODE_DATA).forEach(([nodeId,node]) => {
        if (nodeId !== id) {
          const opt = document.createElement("option");
          opt.value = nodeId;
          opt.textContent = node.name;
          addLineSelect.appendChild(opt);
        }
      });
    }

    function selectTheConnection(id) {
      currentEdgeId = id;

      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";

      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => {
        e.classList.toggle("active", e.dataset.edgeId === id);
      });

      const edge = EDGE_DATA.list.find(e => e.id === id);
      if (!edge) return;

      const directionSymbols = {
        "none": "‚áÑ",
        "forward": "‚Üí",
        "backward": "‚Üê",
        "both": "‚Üî"
      };
      const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";

      let titleText = "Custom line";
      if (edge.from || edge.to) {
        const fromName = edge.from ? (NODE_DATA[edge.from]?.name || edge.from) : "";
        const toName = edge.to ? (NODE_DATA[edge.to]?.name || edge.to) : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
      }

      document.getElementById("edge-title").textContent = titleText;

      const widthInput = document.getElementById("edge-width");
      const colorInput = document.getElementById("edge-color");
      const directionSelect = document.getElementById("edge-direction");
      const lineStyleSelect = document.getElementById("edge-line-style");
      widthInput.value = edge.width;
      colorInput.value = edge.color;
      directionSelect.value = edge.direction || "none";
      lineStyleSelect.value = edge.lineStyle || "solid";

      const list = document.getElementById("edge-notes");
      list.innerHTML = "";

      edge.notes.forEach((note,i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";

        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "‚úï";
        del.addEventListener("click",(e) => {
          e.stopPropagation();
          challengeTheImmortal("Delete this line note?", () => {
            edge.notes.splice(i,1);
            saveEdgeData();
            selectTheConnection(id);
          });
        });

        txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
        });

        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          edge.notes[i] = txt.textContent;
          saveEdgeData();
        });

        li.append(txt, del);
        list.appendChild(li);
      });
    }

    window.addEventListener("resize", () => {
      forgeTheTopology();
      if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
      } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
      } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
        }
      }
    });

    (function initZoomPan() {
      const viewport = document.getElementById("canvas-viewport");
      const svg = document.getElementById("map");
      const hint = document.getElementById("canvas-hint");

      setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
      }, 1000);

      viewport.addEventListener("wheel", (e) => {
        e.preventDefault();

        const rect = viewport.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) / rect.width;
        const mouseY = (e.clientY - rect.top) / rect.height;

        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        zoomTo(canvasState.zoom * delta, mouseX, mouseY);
      }, { passive: false });

      let initialPinchDistance = 0;
      let initialPinchZoom = 1;
      let pinchCenter = { x: 0.5, y: 0.5 };

      viewport.addEventListener("touchstart", (e) => {
        if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          initialPinchZoom = canvasState.zoom;

          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
        }
      }, { passive: false });

      viewport.addEventListener("touchmove", (e) => {
        if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );

          if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
        }
      }, { passive: false });

      let panStartViewX = 0;
      let panStartViewY = 0;

      viewport.addEventListener("mousedown", (e) => {

        if (e.target.closest('.draw-toolbar') || 
            e.target.closest('.topology-toolbar') || 
            e.target.closest('.legend-container')) {
          return;
        }

        const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";

        if (isEmptySpace || canvasState.spacePressed) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
        }
      });

      viewport.addEventListener("touchstart", (e) => {

        if (e.target.closest('.draw-toolbar') || 
            e.target.closest('.topology-toolbar') || 
            e.target.closest('.legend-container')) {
          return;
        }

        const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";

        if (isEmptySpace && e.touches.length === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.touches[0].clientX;
          canvasState.panStartY = e.touches[0].clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
        }
      }, { passive: false });

      document.addEventListener("mousemove", (e) => {
        if (!canvasState.isPanning) return;

        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;

        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;

        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;

        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;

        constrainPan();
        updateViewBox();
      });

      document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;

        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;

        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;

        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;

        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;

        constrainPan();
        updateViewBox();
      });

      document.addEventListener("mouseup", () => {
        if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
        }
      });

      document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
        }
      });

      document.addEventListener("keydown", (e) => {

        const isEditing = document.activeElement.tagName === "INPUT" || 
                         document.activeElement.tagName === "TEXTAREA" ||
                         document.activeElement.isContentEditable;

        if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
        }
      });

      document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
      });

      document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
      });

      document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
      document.getElementById("zoom-reset-btn").addEventListener("click", resetView);

      const minimapContainer = document.getElementById("minimap-container");
      const minimapSvg = document.getElementById("minimap");
      let minimapDragging = false;

      minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
      });

      minimapContainer.addEventListener("touchstart", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimapTouch(e);
      }, { passive: false });

      document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
          updatePanFromMinimap(e);
        }
      });

      document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
        }
      });

      document.addEventListener("mouseup", () => {
        minimapDragging = false;
      });

      document.addEventListener("touchend", () => {
        minimapDragging = false;
      });

      function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;

        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;

        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;

        constrainPan();
        updateViewBox();
      }

      function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;

        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;

        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;

        constrainPan();
        updateViewBox();
      }

      document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;

        if ((e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
        }
      });

      setTimeout(() => {
        fitToContent();
      }, 100);
    })();

    const sizeSlider = document.getElementById("size-slider");
    const sizeValue = document.getElementById("size-value");
    const resetSizeBtn = document.getElementById("reset-size");

    sizeSlider.addEventListener("input", () => {
      const newSize = parseInt(sizeSlider.value, 10);
      sizeValue.textContent = newSize;
      savedSizes[currentNodeId] = newSize;

      const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
      if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();

        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.stroke = styles.circleColor;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);

        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = (styles.titleSize || (newSize * 0.33));
          label.style.fontSize = labelSize + "px";
        }
        if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = (styles.subSize || (newSize * 0.24));
          sub.style.fontSize = subSize + "px";
        }
      }
    });

    resetSizeBtn.addEventListener("click", () => {
      delete savedSizes[currentNodeId];

      const defaultSize = getDefaultSize();
      sizeSlider.value = defaultSize;
      sizeValue.textContent = defaultSize;

      const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
      if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();

        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);

        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.stroke = styles.circleColor;

        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = (styles.titleSize || (defaultSize * 0.33));
          label.style.fontSize = labelSize + "px";
        }
        if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = (styles.subSize || (defaultSize * 0.24));
          sub.style.fontSize = subSize + "px";
        }
      }
    });

    const applyStyle = (property, value) => {
      const styleEntry = ensureStyleEntry(currentNodeId);
      const scopeKey = currentStyleScope || "all";
      if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
      styleEntry[scopeKey][property] = value;

      const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
      if (!nodeGroup) return;
      const shapeEl = nodeGroup.querySelector(".node-circle");
      const label = nodeGroup.querySelector(".node-label");
      const sub = nodeGroup.querySelector(".node-sub");

      if (property === "circleColor" && shapeEl) shapeEl.style.stroke = value;
      else if (property === "titleColor" && label) label.style.fill = value;
      else if (property === "titleFont" && label) label.style.fontFamily = value;
      else if (property === "titleSize" && label) label.style.fontSize = value + "px";
      else if (property === "subColor" && sub) sub.style.fill = value;
      else if (property === "subFont" && sub) sub.style.fontFamily = value;
      else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
    };

    document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value));
    document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value));
    document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value));
    document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)));
    document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value));
    document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value));
    document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)));

    document.getElementById("title-offset-y").addEventListener("input", (e) => {
      applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
      forgeTheTopology();
      if (currentNodeId) claimTheImmortal(currentNodeId);
    });
    document.getElementById("title-offset-x").addEventListener("input", (e) => {
      applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
      forgeTheTopology();
      if (currentNodeId) claimTheImmortal(currentNodeId);
    });
    document.getElementById("sub-offset-y").addEventListener("input", (e) => {
      applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
      forgeTheTopology();
      if (currentNodeId) claimTheImmortal(currentNodeId);
    });
    document.getElementById("sub-offset-x").addEventListener("input", (e) => {
      applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
      forgeTheTopology();
      if (currentNodeId) claimTheImmortal(currentNodeId);
    });

    document.getElementById("reset-styles").addEventListener("click", () => {
      delete savedStyles[currentNodeId];
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
    });

    document.getElementById("style-scope").addEventListener("change", (e) => {
      currentStyleScope = e.target.value || "all";
      claimTheImmortal(currentNodeId);
    });

    document.getElementById("shape-select").addEventListener("change", (e) => {
      const shape = e.target.value || "circle";
      NODE_DATA[currentNodeId].shape = shape;
      const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
      if (!nodeGroup) return;
      const oldShape = nodeGroup.querySelector(".node-circle");
      if (oldShape) oldShape.remove();
      const size = savedSizes[currentNodeId] || getDefaultSize();
      const newShape = createNodeShape(currentNodeId, size);
      nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
    });

    const addNoteBtn = document.getElementById("add-note-btn");
    const noteInput = document.getElementById("new-note-input");

    addNoteBtn.addEventListener("click",() => {
      const newNote = noteInput.value.trim();
      if (newNote && currentNodeId) {
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
      }
    });

    noteInput.addEventListener("keypress",(e) => {
      if (e.key === "Enter") {
        addNoteBtn.click();
      }
    });

    document.getElementById("edge-width").addEventListener("input", () => {
      if (!currentEdgeId) return;
      const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
      if (!edge) return;
      const v = parseInt(document.getElementById("edge-width").value, 10);
      if (Number.isNaN(v) || v <= 0) return;
      edge.width = v;
      saveEdgeData();
      const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
      if (el) el.style.strokeWidth = v;
    });

    document.getElementById("edge-color").addEventListener("input", () => {
      if (!currentEdgeId) return;
      const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
      if (!edge) return;
      const color = document.getElementById("edge-color").value;
      edge.color = color;
      saveEdgeData();
      const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
      if (el) el.style.stroke = color;
      forgeTheLegend();
    });

    document.getElementById("edge-direction").addEventListener("change", () => {
      if (!currentEdgeId) return;
      const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
      if (!edge) return;
      edge.direction = document.getElementById("edge-direction").value;
      saveEdgeData();
      forgeTheTopology();
      selectTheConnection(currentEdgeId);
    });

    document.getElementById("edge-line-style").addEventListener("change", () => {
      if (!currentEdgeId) return;
      const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
      if (!edge) return;
      edge.lineStyle = document.getElementById("edge-line-style").value;
      saveEdgeData();
      forgeTheTopology();
      selectTheConnection(currentEdgeId);
    });

    const addEdgeNoteBtn = document.getElementById("add-edge-note");
    const newEdgeNoteInput = document.getElementById("new-edge-note");

    addEdgeNoteBtn.addEventListener("click", () => {
      const txt = newEdgeNoteInput.value.trim();
      if (!txt || !currentEdgeId) return;
      const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
      if (!edge) return;
      edge.notes.push(txt);
      saveEdgeData();
      newEdgeNoteInput.value = "";
      selectTheConnection(currentEdgeId);
    });

    newEdgeNoteInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        addEdgeNoteBtn.click();
      }
    });

    document.getElementById("delete-edge").addEventListener("click", () => {
      if (!currentEdgeId) return;
      challengeTheImmortal("Are you sure you want to delete this line?", () => {
        EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
        saveEdgeData();
        currentEdgeId = null;
        forgeTheTopology();
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
        } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
        }
      });
    });

    document.getElementById("add-line-btn").addEventListener("click", () => {
      if (!currentNodeId) return;
      const select = document.getElementById("add-line-select");
      const directionSelect = document.getElementById("add-line-direction");
      const colorInput = document.getElementById("add-line-color");
      const targetId = select.value;
      if (!targetId || targetId === currentNodeId) return;

      const direction = directionSelect.value || "none";
      const lineColor = colorInput.value || "#475569";

      const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
      const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: []
      };

      EDGE_DATA.list.push(newEdge);
      saveEdgeData();
      forgeTheTopology();

      claimTheImmortal(currentNodeId);
    });

    let freeDrawMode = false;
    let freeDrawPoints = [];
    let freeDrawPolylineEl = null;
    let freeDrawPointEls = [];

    const drawToggleBtn = document.getElementById("draw-toggle");
    const drawUndoBtn = document.getElementById("draw-undo");
    const drawColorInput = document.getElementById("draw-color");
    const drawStyleSelect = document.getElementById("draw-style");
    const drawArrowSelect = document.getElementById("draw-arrow");
    const svgMap = document.getElementById("map");

    function updateFreeDrawGraphics() {
      const ns = "http://www.w3.org/2000/svg";
      const svg = svgMap;

      if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns,"polyline");
        freeDrawPolylineEl.classList.add("edge","free-preview");
        freeDrawPolylineEl.setAttribute("fill","none");
        svg.appendChild(freeDrawPolylineEl);
      }

      if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
        } else {
          const ptsStr = freeDrawPoints.map(p => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;

          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
            freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
            freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
            freeDrawPolylineEl.style.strokeDasharray = "none";
          }
        }
      }

      freeDrawPointEls.forEach(el => el.remove());
      freeDrawPointEls = [];

      freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns,"circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);

        c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;

          const moveHandler = (ev) => {
            if (!dragging) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.clientX;
            pt.y = ev.clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
          };

          const upHandler = () => {
            dragging = false;
            document.removeEventListener("mousemove", moveHandler);
            document.removeEventListener("mouseup", upHandler);
          };

          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
        });

        c.addEventListener("touchstart", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;

          const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
          };

          const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler);
            document.removeEventListener("touchend", touchUpHandler);
          };

          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
        }, { passive: false });

        svg.appendChild(c);
        freeDrawPointEls.push(c);
      });

      drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
    }

    function addFreeDrawPoint(x, y) {
      freeDrawPoints.push({x,y});
      updateFreeDrawGraphics();
    }

    function startFreeDraw() {
      freeDrawMode = true;
      freeDrawPoints = [];
      if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
      }
      freeDrawPointEls.forEach(el => el.remove());
      freeDrawPointEls = [];
      svgMap.style.cursor = "crosshair";
      drawToggleBtn.textContent = "Done";
      drawUndoBtn.style.display = "none";
    }

    function finishFreeDraw() {
      freeDrawMode = false;
      svgMap.style.cursor = "";
      drawToggleBtn.textContent = "‚úèÔ∏è";

      if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map(p => ({x:p.x, y:p.y}));
        EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: []
        });
        saveEdgeData();

        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach(el => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
      } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach(el => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
      }

      drawUndoBtn.style.display = "none";
    }

    drawToggleBtn.addEventListener("click", () => {
      if (freeDrawMode) {
        finishFreeDraw();
      } else {
        startFreeDraw();
      }
    });

    drawUndoBtn.addEventListener("click", () => {
      if (!freeDrawMode || !freeDrawPoints.length) return;
      freeDrawPoints.pop();
      updateFreeDrawGraphics();
    });

    const drawToolbar = document.getElementById("draw-toolbar");

    drawToolbar.addEventListener("mousedown", (e) => {
      e.stopPropagation();
    });

    drawToolbar.addEventListener("click", (e) => {

      if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
      }
    });

    drawStyleSelect.addEventListener("change", () => {
      if (freeDrawMode) {
        updateFreeDrawGraphics();
      }
    });

    drawArrowSelect.addEventListener("change", () => {
      if (freeDrawMode) {
        updateFreeDrawGraphics();
      }
    });

    drawColorInput.addEventListener("input", () => {
      if (freeDrawMode) {
        updateFreeDrawGraphics();
      }
    });

    drawStyleSelect.addEventListener("mousedown", (e) => {
      e.stopPropagation();
    });

    drawStyleSelect.addEventListener("click", (e) => {
      e.stopPropagation();
    });

    drawArrowSelect.addEventListener("mousedown", (e) => {
      e.stopPropagation();
    });

    drawArrowSelect.addEventListener("click", (e) => {
      e.stopPropagation();
    });

    drawColorInput.addEventListener("mousedown", (e) => {
      e.stopPropagation();
    });

    drawColorInput.addEventListener("click", (e) => {
      e.stopPropagation();
    });

    svgMap.addEventListener("click", (e) => {
      if (!freeDrawMode) return;
      if (e.button !== 0) return;
      const target = e.target;
      if (target && target.classList && target.classList.contains("free-point")) return;
      const svgEl = svgMap;
      const pt = svgEl.createSVGPoint();
      pt.x = e.clientX;
      pt.y = e.clientY;
      const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
      addFreeDrawPoint(svgP.x, svgP.y);
    });

    svgMap.addEventListener("touchend", (e) => {
      if (!freeDrawMode) return;
      const target = e.target;
      if (target && target.classList && target.classList.contains("free-point")) return;
      if (e.changedTouches && e.changedTouches[0]) {
        e.preventDefault();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.changedTouches[0].clientX;
        pt.y = e.changedTouches[0].clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
      }
    }, { passive: false });

    const settingsBtn = document.getElementById("settings-btn");
    const settingsModal = document.getElementById("settings-modal");
    const settingsClose = document.getElementById("settings-close");

    settingsBtn.addEventListener("click", () => {

      document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
      document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
      document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
      document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
      document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
      document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
      document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
      document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
      document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";

      settingsModal.classList.add("active");
    });

    settingsClose.addEventListener("click", () => {
      settingsModal.classList.remove("active");
    });

    settingsModal.addEventListener("click", (e) => {
      if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
      }
    });

    document.getElementById("page-bg-color").addEventListener("input", (e) => {
      PAGE_STATE.background = e.target.value;
      wieldThePower();
    });

    document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
      PAGE_STATE.topbarBg = e.target.value;
      wieldThePower();
    });

    document.getElementById("topbar-border-color").addEventListener("input", (e) => {
      PAGE_STATE.topbarBorder = e.target.value;
      wieldThePower();
    });

    document.getElementById("panel-color").addEventListener("input", (e) => {
      PAGE_STATE.panel = e.target.value;
      wieldThePower();
    });

    document.getElementById("panel-alt-color").addEventListener("input", (e) => {
      PAGE_STATE.panelAlt = e.target.value;
      wieldThePower();
    });

    document.getElementById("accent-color").addEventListener("input", (e) => {
      PAGE_STATE.accent = e.target.value;
      wieldThePower();
    });

    document.getElementById("danger-color").addEventListener("input", (e) => {
      PAGE_STATE.danger = e.target.value;
      wieldThePower();
    });

    document.getElementById("text-main-color").addEventListener("input", (e) => {
      PAGE_STATE.textMain = e.target.value;
      wieldThePower();
    });

    document.getElementById("text-soft-color").addEventListener("input", (e) => {
      PAGE_STATE.textSoft = e.target.value;
      wieldThePower();
    });

    document.getElementById("topbar-height").addEventListener("input", (e) => {
      PAGE_STATE.topbarHeight = parseInt(e.target.value, 10);
      document.getElementById("topbar-height-val").textContent = PAGE_STATE.topbarHeight + "px";
      wieldThePower();
    });

    document.getElementById("sidebar-width").addEventListener("input", (e) => {
      PAGE_STATE.sidebarWidth = parseInt(e.target.value, 10);
      document.getElementById("sidebar-width-val").textContent = PAGE_STATE.sidebarWidth + "px";
      wieldThePower();
    });

    document.getElementById("mobile-footer-height").addEventListener("input", (e) => {
      PAGE_STATE.mobileFooterHeight = parseInt(e.target.value, 10);
      document.getElementById("mobile-footer-height-val").textContent = PAGE_STATE.mobileFooterHeight + "%";
      wieldThePower();
    });

    document.getElementById("sidebar-toggle").addEventListener("click", () => {
      PAGE_STATE.sidebarCollapsed = !PAGE_STATE.sidebarCollapsed;
      wieldThePower();
    });

    document.getElementById("export-data-btn").addEventListener("click", () => {
      const data = captureTheQuickening();
      const jsonStr = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      const safeTitle = (PAGE_STATE.title || "network-topology")
        .toLowerCase()
        .replace(/[^a-z0-9\-]+/g, "-");
      const timestamp = new Date().toISOString().split('T')[0];
      a.download = `${safeTitle}-data-${timestamp}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    document.getElementById("import-data-btn").addEventListener("click", () => {
      document.getElementById("import-data-file").click();
    });

    document.getElementById("import-data-file").addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      try {
        const text = await file.text();
        const data = JSON.parse(text);

        if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
        }

        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n\nContinue?`;
        if (!confirm(confirmMsg)) {
          e.target.value = ""; 
          return;
        }

        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};

        if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page);
          wieldThePower();
        }

        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
        }

        if (data.page?.title) {
          document.title = data.page.title;
          document.querySelector(".editable-page-title").textContent = data.page.title;
        }

        forgeTheTopology();
        forgeTheLegend();
        updateViewBox();

        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
        } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
        }

        alert("Data imported successfully!");
        e.target.value = ""; 
      } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = ""; 
      }
    });

    const saveHelpBtn = document.getElementById("save-help-btn");
    const saveInfoModal = document.getElementById("save-info-modal");
    const saveInfoClose = document.getElementById("save-info-close");

    saveHelpBtn.addEventListener("click", () => {
      saveInfoModal.classList.add("active");
    });

    saveInfoClose.addEventListener("click", () => {
      saveInfoModal.classList.remove("active");
    });

    saveInfoModal.addEventListener("click", (e) => {
      if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
      }
    });

    async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw',
        encoder.encode(password),
        'PBKDF2',
        false,
        ['deriveKey']
      );

      return crypto.subtle.deriveKey(
        {
          name: 'PBKDF2',
          salt: salt,
          iterations: 100000,
          hash: 'SHA-256'
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
      );
    }

    async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);

      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encoder.encode(data)
      );

      const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(new Uint8Array(encrypted), salt.length + iv.length);

      return 'ENCRYPTED:' + btoa(String.fromCharCode(...result));
    }

    async function decryptData(encryptedData, password) {

      const base64Data = encryptedData.replace('ENCRYPTED:', '');
      const data = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));

      const salt = data.slice(0, 16);
      const iv = data.slice(16, 28);
      const encrypted = data.slice(28);

      const key = await deriveKey(password, salt);

      const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        encrypted
      );

      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
    }

    function isEncrypted(data) {
      return typeof data === 'string' && data.startsWith('ENCRYPTED:');
    }

    function captureTheQuickening() {
      return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY
        }
      };
    }

    function assembleTheImmortalForm() {
      const clone = document.documentElement.cloneNode(true);

      const nodeScript = clone.querySelector("#nodes-json");
      if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
      }

      let stateScript = clone.querySelector("#topology-state");
      if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
      }
      stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2);

      return "<!DOCTYPE html>\n" + clone.outerHTML;
    }

    async function becomeImmortal() {
      const encryptEnabled = document.getElementById('encrypt-toggle').checked;
      let stateData = JSON.stringify(captureTheQuickening(), null, 2);

      if (encryptEnabled) {
        const password = prompt('Enter a password to encrypt your data:\n(Remember this password - you will need it to open this file!)');
        if (!password) {
          alert('Encryption cancelled. File not saved.');
          return;
        }

        const confirmPassword = prompt('Confirm your password:');
        if (password !== confirmPassword) {
          alert('Passwords do not match. File not saved.');
          return;
        }

        try {
          stateData = await encryptData(stateData, password);
        } catch (e) {
          alert('Encryption failed: ' + e.message);
          return;
        }
      }

      const clone = document.documentElement.cloneNode(true);

      const nodeScript = clone.querySelector("#nodes-json");
      if (nodeScript) {
        if (encryptEnabled) {

          nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
      }

      let stateScript = clone.querySelector("#topology-state");
      if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
      }
      stateScript.textContent = stateData;

      const html = "<!DOCTYPE html>\n" + clone.outerHTML;
      const blob = new Blob([html], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      const safeTitle = (PAGE_STATE.title || document.title || "network-topology")
        .toLowerCase()
        .replace(/[^a-z0-9\-]+/g,"-");
      a.download = safeTitle + ".html";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);

    const addNodeBtn = document.getElementById("add-node-btn");
    const addNodeModal = document.getElementById("add-node-modal");
    const addNodeCancel = document.getElementById("add-node-cancel");
    const addNodeSave = document.getElementById("add-node-save");

    addNodeBtn.addEventListener("click", () => {

      document.getElementById("new-node-name").value = "";
      document.getElementById("new-node-ip").value = "";
      document.getElementById("new-node-tags").value = "";
      document.getElementById("new-node-shape").value = "circle";
      addNodeModal.classList.add("active");
      document.getElementById("new-node-name").focus();
    });

    addNodeCancel.addEventListener("click", () => {
      addNodeModal.classList.remove("active");
    });

    addNodeModal.addEventListener("click", (e) => {
      if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
      }
    });

    addNodeSave.addEventListener("click", () => {
      const name = document.getElementById("new-node-name").value.trim();
      const ip = document.getElementById("new-node-ip").value.trim();
      const tagsStr = document.getElementById("new-node-tags").value.trim();
      const shape = document.getElementById("new-node-shape").value;

      if (!name) {
        alert("Please enter a node name.");
        return;
      }

      const tags = tagsStr ? tagsStr.split(",").map(t => t.trim()).filter(t => t) : [];

      let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
      if (!baseId) baseId = "node";
      let nodeId = baseId;
      let counter = 1;
      while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
      }

      NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: []
      };

      const centerX = CANVAS_WIDTH / 2;
      const centerY = CANVAS_HEIGHT / 2;
      savedPositions[nodeId] = { x: centerX, y: centerY };

      addNodeModal.classList.remove("active");
      forgeTheTopology();
      claimTheImmortal(nodeId);
    });

    ["new-node-name", "new-node-ip", "new-node-tags"].forEach(inputId => {
      document.getElementById(inputId).addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          addNodeSave.click();
        }
      });
    });

    const clearAllBtn = document.getElementById("clear-all-btn");
    const clearAllModal = document.getElementById("clear-all-modal");
    const clearAllCancel = document.getElementById("clear-all-cancel");
    const clearAllConfirm = document.getElementById("clear-all-confirm");

    clearAllBtn.addEventListener("click", () => {
      clearAllModal.classList.add("active");
    });

    clearAllCancel.addEventListener("click", () => {
      clearAllModal.classList.remove("active");
    });

    clearAllModal.addEventListener("click", (e) => {
      if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
      }
    });

    clearAllConfirm.addEventListener("click", () => {

      NODE_DATA = {};
      EDGE_DATA = { list: [] };
      EDGE_LEGEND = {};
      savedPositions = {};
      savedSizes = {};
      savedStyles = {};

      clearAllModal.classList.remove("active");

      forgeTheTopology();

      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("topology-toolbar").style.display = "none";

      currentNodeId = null;
      currentEdgeId = null;
    });
function screenshotCanvasSVG() {
  const svg = document.getElementById("map");
  const svgClone = svg.cloneNode(true);
  
  const bbox = svg.getBBox ? svg.getBBox() : { x: 100, y: 100, width: 3800, height: 2800 };
  svgClone.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
  
  const svgData = new XMLSerializer().serializeToString(svgClone);
  const blob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement("a");
  link.download = "topology-screenshot.svg";
  link.href = url;
  link.click();
  URL.revokeObjectURL(url);
}
function screenshotCanvas() {
  const svg = document.getElementById("map");
  const svgClone = svg.cloneNode(true);
  
  // Get the actual content bounds (you might want to adjust this based on your nodes)
  const bbox = svg.getBBox ? svg.getBBox() : { x: 100, y: 100, width: 3800, height: 2800 };
  
  // Set viewBox to capture the content area
  svgClone.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
  svgClone.setAttribute("width", bbox.width);
  svgClone.setAttribute("height", bbox.height);
  
  // Serialize the SVG
  const svgData = new XMLSerializer().serializeToString(svgClone);
  const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
  const url = URL.createObjectURL(svgBlob);
  
  // Create an image to convert SVG to PNG
  const img = new Image();
  img.onload = function() {
    // Create a canvas to draw the image
    const canvas = document.createElement("canvas");
    canvas.width = bbox.width;
    canvas.height = bbox.height;
    const ctx = canvas.getContext("2d");
    
    // Fill background (optional - remove for transparent)
    ctx.fillStyle = "#050608"; // Your background color
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw the SVG image
    ctx.drawImage(img, 0, 0);
    
    // Convert to PNG and download
    canvas.toBlob(function(blob) {
      const link = document.createElement("a");
      link.download = "topology-screenshot.png";
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(url);
      URL.revokeObjectURL(link.href);
    });
  };
  img.src = url;
}

document.getElementById("screenshot-btn").addEventListener("click", screenshotCanvas);

    (function addDeleteNodeButton() {
      const nodePanel = document.getElementById("node-panel");
      if (!nodePanel) return;

      if (document.getElementById("delete-node-btn")) return;

      const deleteBtn = document.createElement("button");
      deleteBtn.id = "delete-node-btn";
      deleteBtn.textContent = "Delete Node";
      deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";

      deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`, () => {

          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);

          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];

          currentNodeId = null;
          currentEdgeId = null;

          forgeTheTopology();

          const remainingNodes = Object.keys(NODE_DATA);
          if (remainingNodes.length > 0) {
            claimTheImmortal(remainingNodes[0]);
          } else {
            document.getElementById("node-panel").style.display = "none";
            document.getElementById("edge-panel").style.display = "none";
            document.getElementById("topology-toolbar").style.display = "none";
          }
        });
      });

      nodePanel.appendChild(deleteBtn);
    })();
								 
	function screenshotCanvas() {
      const svg = document.getElementById("map");
      const svgClone = svg.cloneNode(true);
      
      // Get the viewBox or create one based on content
      const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
      const [x, y, width, height] = viewBox;
      
      // Set dimensions
      svgClone.setAttribute("width", width);
      svgClone.setAttribute("height", height);
      svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
      
      // Create a wrapper to hold our styled SVG
      const wrapper = document.createElement("div");
      wrapper.style.position = "absolute";
      wrapper.style.left = "-9999px";
      wrapper.appendChild(svgClone);
      document.body.appendChild(wrapper);
      
      // Inline all styles for each element
      function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        
        // Get root CSS variables
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue('--bg').trim() || '#050608';
        
        // Add background rectangle at the beginning
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        
        // Inline styles for each element
        elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          
          const computedStyle = getComputedStyle(el);
          
          // SVG-specific properties to inline
          const svgProps = [
            'fill', 'stroke', 'stroke-width', 'stroke-dasharray', 
            'stroke-linecap', 'stroke-linejoin', 'opacity',
            'font-family', 'font-size', 'font-weight', 'font-style',
            'text-anchor', 'dominant-baseline', 'marker-start', 'marker-end'
          ];
          
          svgProps.forEach(prop => {
            const value = computedStyle.getPropertyValue(prop);
            if (value && value !== 'none' && value !== 'normal') {
              clonedEl.style[prop] = value;
            }
          });
          
          // Remove classes since we've inlined the styles
          clonedEl.removeAttribute('class');
        });
      }
      
      inlineStyles(svg, svgClone);
      
      // Serialize the styled SVG
      const svgData = new XMLSerializer().serializeToString(svgClone);
      
      // Clean up
      document.body.removeChild(wrapper);
      
      // Create blob and image
      const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(svgBlob);
      
      const img = new Image();
      img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        
        // Draw the image
        ctx.drawImage(img, 0, 0);
        
        // Convert to PNG and download
        canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          
          // Cleanup
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
        }, 'image/png');
      };
      
      img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
      };
      
      img.src = url;
    }

    // Also provide an SVG export option (keeps it vector/scalable)
    function exportCanvasSVG() {
      const svg = document.getElementById("map");
      const svgClone = svg.cloneNode(true);
      
      const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
      const [x, y, width, height] = viewBox;
      
      svgClone.setAttribute("width", width);
      svgClone.setAttribute("height", height);
      
      // Get background color
      const rootStyles = getComputedStyle(document.documentElement);
      const bgColor = rootStyles.getPropertyValue('--bg').trim() || '#050608';
      
      // Add background
      const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      bgRect.setAttribute("x", x);
      bgRect.setAttribute("y", y);
      bgRect.setAttribute("width", width);
      bgRect.setAttribute("height", height);
      bgRect.setAttribute("fill", bgColor);
      svgClone.insertBefore(bgRect, svgClone.firstChild);
      
      // Inline styles
      const wrapper = document.createElement("div");
      wrapper.style.position = "absolute";
      wrapper.style.left = "-9999px";
      wrapper.appendChild(svgClone);
      document.body.appendChild(wrapper);
      
      const elements = svg.querySelectorAll("*");
      const clonedElements = svgClone.querySelectorAll("*");
      
      elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        
        const computedStyle = getComputedStyle(el);
        const svgProps = [
          'fill', 'stroke', 'stroke-width', 'stroke-dasharray',
          'stroke-linecap', 'stroke-linejoin', 'opacity',
          'font-family', 'font-size', 'font-weight', 'font-style',
          'text-anchor', 'dominant-baseline', 'marker-start', 'marker-end'
        ];
        
        svgProps.forEach(prop => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== 'none' && value !== 'normal') {
            clonedEl.setAttribute(prop, value);
          }
        });
        
        clonedEl.removeAttribute('class');
      });
      
      const svgData = new XMLSerializer().serializeToString(svgClone);
      document.body.removeChild(wrapper);
      
      const blob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement("a");
      const timestamp = new Date().toISOString().slice(0, 10);
      link.download = `topology-${timestamp}.svg`;
      link.href = url;
      link.click();
      
      URL.revokeObjectURL(url);
    }																					 
  </script>
</body></html>