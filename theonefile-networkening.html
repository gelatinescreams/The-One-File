<!DOCTYPE html>
<html lang="en" style="
   --panel: #0b0e13;
   --panel-alt: #10141b;
   --accent: #4fd1c5;
   --danger: #f56565;
   --text-main: #e2e8f0;
   --text-soft: #94a3b8;
   --topbar-bg: rgba(9, 12, 20, 0.9);
   --topbar-border: #1f2533;
   --topbar-height: 100px;
   --sidebar-width: 435px;
   --mobile-footer-height: 20vh;
   ">
 <head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>The One File: The Networkening</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- 
         * ==================================================================================
         * The One File: The Networkening
		 * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
		 * Online version uses 3 cdns from cdn.jsdelivr.net to pull extra icons only
         * "There can be only one". A all in one file topology maker.
         * 
         * This is your last backup when all others fail. A completely self-contained
         * network topology visualization tool that works as a single HTML file.
         * Open it anywhere, anytime and the idea lives forever.
         * ==================================================================================
         -->
  <style>
   :root {
    color-scheme: dark;
    --bg: #050608;
    --panel: #0b0e13;
    --panel-alt: #10141b;
    --accent: #4fd1c5;
    --danger: #f56565;
    --text-main: #e2e8f0;
    --text-soft: #94a3b8;
    --edge-main: #475569;
    --node-min: 35px;
    --node-max: 70px;
    --topbar-bg: rgba(9, 12, 20, 0.9);
    --topbar-border: #1f2533;
   }

   * {
    box-sizing: border-box;
    user-select: none;
   }

   input,
   textarea,
   [contenteditable="true"] {
    user-select: text;
    -webkit-user-select: text;
   }

   body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
    color: var(--text-main);
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
   }

   header {
    padding: 0 20px;
    height: var(--topbar-height, 52px);
    min-height: var(--topbar-height, 52px);
    background: var(--topbar-bg);
    backdrop-filter: blur(6px);
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--topbar-border);
    gap: 16px;
   }

   .title-block {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 0;
   }

   header h1 {
    font-size: clamp(22px, 3vw, 32px);
    margin: 0;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
   }

   .editable-page-title {
    cursor: pointer;
    transition: opacity 0.2s;
   }

   .editable-page-title:hover {
    opacity: 0.7;
   }

   .save-row {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
   }

   .save-btn {
    padding: 6px 12px;
    background: var(--accent);
    color: var(--bg);
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    white-space: nowrap;
   }

   .save-btn:hover {
    opacity: 0.9;
   }

   .help-icon {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    border: 1px solid var(--edge-main);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-soft);
    background: rgba(15, 23, 42, 0.9);
    flex-shrink: 0;
   }

   .help-icon:hover {
    color: var(--accent);
    border-color: var(--accent);
   }

   #settings-btn {
    background: var(--panel);
    color: var(--text-main);
    border: 1px solid var(--edge-main);
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    flex-shrink: 0;
   }

   #settings-btn:hover {
    background: var(--accent);
    color: var(--bg);
   }

   main {
    display: grid;
    grid-template-columns: 1fr var(--sidebar-width, 350px);
    flex: 1;
   }

   main.sidebar-collapsed {
    grid-template-columns: 1fr 0;
   }

   @media (max-width: 1024px) {
    main {
     grid-template-columns: 1fr var(--sidebar-width, 300px);
    }
   }

   @media (max-width: 768px) {
    main {
     grid-template-columns: 1fr;
     grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
    }

    main.sidebar-collapsed {
     grid-template-rows: 1fr 0;
    }

    .details-panel {
     max-height: var(--mobile-footer-height, 40vh);
     height: 100%;
    }
   }

   @media (max-width: 380px) {
    main {
     grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
    }
   }

   .topology-panel {
    background: var(--panel);
    border-right: 1px solid #111827;
    position: relative;
    overflow: hidden;
   }

   .topology-toolbar {
    position: absolute;
    top: 10px;
    right: 10px;
    display: none;
    align-items: center;
    gap: 8px;
    padding: 6px 10px;
    background: rgba(15, 23, 42, 0.92);
    border: 1px solid #1f2937;
    border-radius: 6px;
    z-index: 20;
    font-size: 13px;
   }

   .topology-toolbar label {
    color: var(--text-soft);
   }

   .topology-toolbar select {
    padding: 4px 6px;
    background: var(--panel);
    border: 1px solid var(--edge-main);
    border-radius: 4px;
    color: var(--text-main);
    font-size: 13px;
    cursor: pointer;
   }

   .topology-toolbar button {
    padding: 4px 10px;
    background: var(--accent);
    color: var(--bg);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
   }

   .draw-toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    background: rgba(15, 23, 42, 0.92);
    border: 1px solid #1f2937;
    border-radius: 6px;
    z-index: 20;
    font-size: 13px;
    pointer-events: auto;
   }

   .draw-toolbar button {
    padding: 4px 8px;
    background: var(--panel);
    color: var(--text-main);
    border: 1px solid var(--edge-main);
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
   }

   .draw-toolbar button:hover {
    background: var(--accent);
    color: var(--bg);
   }

   .draw-toolbar input[type="color"] {
    width: 30px;
    height: 22px;
    border-radius: 4px;
    border: 1px solid var(--edge-main);
    padding: 0;
    background: transparent;
    cursor: pointer;
   }

   .draw-toolbar select {
    padding: 4px 6px;
    background: var(--panel);
    border: 1px solid var(--edge-main);
    border-radius: 4px;
    color: var(--text-main);
    font-size: 13px;
    cursor: pointer;
   }

   .legend-container {
    position: absolute;
    left: 10px;
    bottom: 10px;
    display: none;
    flex-direction: column;
    gap: 6px;
    padding: 8px 10px;
    background: rgba(15, 23, 42, 0.92);
    border: 1px solid #1f2937;
    border-radius: 6px;
    font-size: 12px;
    z-index: 20;
    max-width: 260px;
    pointer-events: auto;
   }

   .legend-container {
    padding-right: 22px;
   }

   .legend-close-btn {
    position: absolute;
    top: -6px;
    right: -6px;
    width: 18px;
    height: 18px;
    border-radius: 999px;
    border: 1px solid var(--edge-main);
    background: var(--panel-alt);
    color: var(--text-soft);
    font-size: 11px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
   }

   .legend-close-btn:hover {
    background: var(--danger);
    color: #fff;
   }

   .legend-mini-btn {
    position: absolute;
    left: 10px;
    bottom: 10px;
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid #1f2937;
    background: rgba(15, 23, 42, 0.92);
    font-size: 12px;
    cursor: pointer;
    z-index: 20;
    display: none;
   }

   .legend-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-soft);
    margin-bottom: 2px;
   }

   .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
   }

   .legend-swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid #020617;
    flex-shrink: 0;
   }

   .legend-label {
    outline: none;
    cursor: text;
    flex: 1;
    min-width: 60px;
    user-select: text;
    -webkit-user-select: text;
   }

   .legend-label.editing {
    border-bottom: 1px dashed var(--accent);
   }

   .canvas-viewport {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    overflow: hidden;
   }

   .canvas-viewport.panning {
    cursor: grabbing !important;
   }

   .canvas-viewport.panning * {
    cursor: grabbing !important;
   }

   .canvas-viewport svg {
    width: 100%;
    height: 100%;
    display: block;
    background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
     linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
     linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
     linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
    background-size:
     100px 100px,
     100px 100px,
     20px 20px,
     20px 20px;
    background-position:
     -1px -1px,
     -1px -1px,
     -1px -1px,
     -1px -1px;
   }

   .zoom-toolbar {
    position: absolute;
    bottom: 10px;
    right: 10px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    padding: 6px;
    background: rgba(15, 23, 42, 0.92);
    border: 1px solid #1f2937;
    border-radius: 6px;
    z-index: 20;
   }

   .zoom-toolbar button {
    width: 32px;
    height: 32px;
    padding: 0;
    background: var(--panel);
    color: var(--text-main);
    border: 1px solid var(--edge-main);
    border-radius: 4px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
   }

   .zoom-toolbar button:hover {
    background: var(--accent);
    color: var(--bg);
   }

   .zoom-toolbar .zoom-level {
    font-size: 11px;
    color: var(--text-soft);
    text-align: center;
    padding: 2px 0;
    min-width: 32px;
   }

   .zoom-toolbar .divider {
    height: 1px;
    background: var(--edge-main);
    margin: 2px 0;
   }

   .minimap-container {
    position: absolute;
    bottom: 10px;
    right: 60px;
    width: 150px;
    height: 100px;
    background: rgba(15, 23, 42, 0.92);
    border: 1px solid #1f2937;
    border-radius: 6px;
    z-index: 19;
    overflow: hidden;
   }

   .minimap-container svg {
    width: 100%;
    height: 100%;
   }

   .minimap-viewport {
    fill: rgba(79, 209, 197, 0.2);
    stroke: var(--accent);
    stroke-width: 2;
    cursor: move;
   }

   .minimap-node {
    fill: var(--text-soft);
   }

   .minimap-edge {
    stroke: var(--edge-main);
    stroke-width: 1;
   }

   .canvas-hint {
    position: absolute;
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 16px;
    background: rgba(15, 23, 42, 0.92);
    border: 1px solid #1f2937;
    border-radius: 6px;
    font-size: 12px;
    color: var(--text-soft);
    z-index: 18;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
   }

   .canvas-hint.visible {
    opacity: 1;
   }

   .edge {
    stroke: var(--edge-main);
    stroke-width: 4;
    opacity: 0.75;
    transition: 0.25s ease-in-out;
    cursor: pointer;
   }

   .edge.backup {
    stroke: var(--danger);
    stroke-width: 5;
   }

   .edge.active {
    opacity: 1;
    stroke-width: 7;
   }

   .free-preview {
    fill: none;
    stroke-dasharray: 4 4;
    pointer-events: none;
   }

   .free-point {
    fill: #e5e7eb;
    stroke: #0f172a;
    stroke-width: 1.5;
    cursor: grab;
   }

   .node-circle {
    fill: #0c111a;
    stroke: #1e293b;
    stroke-width: 4;
    transition: 0.25s ease;
    transform-origin: center center;
   }

   .node-group:hover .node-circle {
    transform: scale(1.08);
    filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
   }

   .node-group:hover .node-label,
   .node-group:hover .node-sub {
    transform: scale(1.08);
   }

   .node-group.active .node-circle {
    stroke: var(--accent);
    animation: pulse 1.2s infinite ease-in-out;
   }

   @keyframes pulse {
    0% {
     filter: drop-shadow(0 0 4px #4fd1c5);
    }

    50% {
     filter: drop-shadow(0 0 14px #4fd1c5);
    }

    100% {
     filter: drop-shadow(0 0 4px #4fd1c5);
    }
   }

   .node-label {
    fill: var(--text-main);
    font-size: 18px;
    text-anchor: middle;
    font-weight: 600;
   }

   .node-sub {
    fill: var(--text-soft);
    font-size: 13px;
    text-anchor: middle;
   }

   @media (max-width: 1024px) {
    .node-label {
     font-size: 28px;
    }

    .node-sub {
     font-size: 20px;
    }
   }

   @media (max-width: 768px) {
    .node-label {
     font-size: 70px;
    }

    .node-sub {
     font-size: 50px;
    }
   }

   @media (max-width: 380px) {
    .node-label {
     font-size: 60px;
    }

    .node-sub {
     font-size: 42px;
    }
   }

   .details-panel {
    background: var(--panel-alt);
    padding: 22px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 15px;
    position: relative;
    transition:
     width 0.3s ease,
     min-width 0.3s ease,
     padding 0.3s ease,
     opacity 0.3s ease;
   }

   .details-panel {
    min-width: 260px !important;
   }

   .details-panel {
    overflow-y: auto !important;
    overflow-x: hidden;
   }

   .details-panel.collapsed {
    width: 0 !important;
    min-width: 0 !important;
    padding: 0 !important;
    overflow: hidden;
    opacity: 0;
   }

   body {
    overflow-x: hidden;
    overflow-y: hidden;
   }

   main {
    overflow-x: hidden;
    overflow-y: visible;
   }

   .details-panel {
    overflow-y: auto !important;
    overflow-x: hidden;
   }

   .details-panel.collapsed {
    min-width: 0 !important;
   }

   .sidebar-toggle {
    position: absolute;
    left: -16px;
    top: 50%;
    transform: translateY(-50%);
    width: 16px;
    height: 60px;
    background: var(--panel-alt);
    border: 1px solid var(--edge-main);
    border-right: none;
    border-radius: 8px 0 0 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-soft);
    font-size: 10px;
    z-index: 25;
    transition:
     background 0.2s,
     color 0.2s;
   }

   .sidebar-toggle:hover {
    background: var(--accent);
    color: var(--bg);
   }

   .sidebar-toggle.collapsed {
    left: 0;
    border-right: 1px solid var(--edge-main);
    border-radius: 0 8px 8px 0;
    position: fixed;
    right: 0;
    left: auto;
   }

   .details-name {
    font-size: clamp(22px, 2.5vw, 30px);
    font-weight: 700;
   }

   .details-ip {
    font-size: clamp(16px, 2vw, 22px);
    color: var(--text-soft);
   }

   .details-role {
    font-size: clamp(16px, 2vw, 22px);
    color: var(--accent);
   }

   .size-controls {
    display: flex;
    gap: 10px;
    align-items: center;
    margin-top: 10px;
   }

   .size-controls label {
    font-size: clamp(14px, 1.6vw, 18px);
    color: var(--text-soft);
   }

   .size-controls input[type="range"] {
    flex: 1;
    accent-color: var(--accent);
   }

   .size-controls button {
    padding: 6px 12px;
    background: var(--panel);
    color: var(--text-main);
    border: 1px solid var(--edge-main);
    border-radius: 4px;
    cursor: pointer;
    font-size: clamp(12px, 1.4vw, 16px);
   }

   .size-controls button:hover {
    background: var(--accent);
    color: var(--bg);
   }

   .style-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid var(--edge-main);
   }

   .style-section summary {
    cursor: pointer;
    font-size: clamp(14px, 1.6vw, 20px);
    text-transform: uppercase;
    color: var(--text-soft);
    list-style: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
    user-select: none;
   }

   .style-section summary::-webkit-details-marker {
    display: none;
   }

   .password-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #ffffff;
    z-index: 9999;
   }

   .style-section summary::after {
    content: "‚ñº";
    transition: transform 0.2s;
   }

   .style-section[open] summary::after {
    transform: rotate(180deg);
   }

   .style-content {
    margin-top: 10px;
   }

   .style-row {
    display: flex;
    gap: 10px;
    align-items: center;
    margin: 8px 0;
   }

   .style-row label {
    font-size: clamp(13px, 1.5vw, 17px);
    color: var(--text-soft);
    min-width: 80px;
   }

   .style-row input[type="color"] {
    width: 50px;
    height: 30px;
    border: 1px solid var(--edge-main);
    border-radius: 4px;
    cursor: pointer;
    background: transparent;
   }

   .style-row input[type="number"] {
    width: 70px;
    padding: 4px 8px;
    background: var(--panel);
    border: 1px solid var(--edge-main);
    border-radius: 4px;
    color: var(--text-main);
    font-size: clamp(12px, 1.4vw, 16px);
   }

   .style-row select {
    flex: 1;
    padding: 4px 8px;
    background: var(--panel);
    border: 1px solid var(--edge-main);
    border-radius: 4px;
    color: var(--text-main);
    font-size: clamp(12px, 1.4vw, 16px);
    cursor: pointer;
   }

   .editable-text {
    cursor: pointer;
    transition: opacity 0.2s;
   }

   .editable-text:hover {
    opacity: 0.7;
   }

   .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 1000;
    justify-content: center;
    align-items: center;
   }

   .modal.active {
    display: flex;
   }

   .modal-content {
    background: var(--panel-alt);
    padding: 25px;
    border-radius: 8px;
    border: 1px solid var(--edge-main);
    min-width: 300px;
    max-width: 90%;
   }

   .modal-content h3 {
    margin: 0 0 15px 0;
    color: var(--text-main);
    font-size: clamp(18px, 2vw, 24px);
   }

   .modal-content p {
    color: var(--text-soft);
    font-size: clamp(14px, 1.6vw, 18px);
    margin: 0 0 20px 0;
   }

   .modal-content input:not([type="color"]),
   .modal-content select {
    width: 100%;
    padding: 10px;
    background: var(--panel);
    border: 1px solid var(--edge-main);
    border-radius: 4px;
    color: var(--text-main);
    font-size: clamp(14px, 1.6vw, 18px);
    margin-bottom: 15px;
    user-select: text;
    -webkit-user-select: text;
   }

   .modal-content input[type="color"] {
    width: 60px;
    height: 36px;
    padding: 2px;
    border: 2px solid var(--edge-main);
    border-radius: 6px;
    cursor: pointer;
    background: none;
    -webkit-appearance: none;
    appearance: none;
   }

   .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
   }

   .modal-content input[type="color"]::-webkit-color-swatch {
    border: none;
    border-radius: 4px;
   }

   .modal-buttons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 10px;
   }

   .modal-buttons button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: clamp(14px, 1.6vw, 18px);
    font-weight: 600;
   }

   .modal-buttons .btn-cancel {
    background: var(--panel);
    color: var(--text-main);
    border: 1px solid var(--edge-main);
   }

   .modal-buttons .btn-save {
    background: var(--accent);
    color: var(--bg);
   }

   .modal-buttons .btn-delete {
    background: var(--danger);
    color: white;
   }

   .confirm-modal p {
    color: var(--text-soft);
    font-size: clamp(14px, 1.6vw, 18px);
    margin: 0 0 20px 0;
   }

   .badge-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
   }

   .badge {
    border: 1px solid var(--edge-main);
    padding: 5px 12px;
    border-radius: 22px;
    font-size: clamp(12px, 1.4vw, 18px);
   }

   .badge.wg {
    color: var(--accent);
    border-color: var(--accent);
   }

   .section-label {
    margin-top: 8px;
    font-size: clamp(14px, 1.6vw, 20px);
    text-transform: uppercase;
    color: var(--text-soft);
   }

   .list li {
    margin: 6px 0;
    font-size: clamp(14px, 1.6vw, 20px);
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
   }

   .list li:hover {
    color: var(--accent);
   }

   .delete-note {
    color: var(--danger);
    font-size: 18px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s;
    flex-shrink: 0;
   }

   .list li:hover .delete-note {
    opacity: 1;
   }

   .editing {
    outline: 2px solid var(--accent);
    background: #0d141f;
    padding: 4px;
    border-radius: 6px;
    user-select: text;
    -webkit-user-select: text;
   }

   .mobile-menu-btn {
    display: none;
    background: var(--panel);
    border: 1px solid var(--edge-main);
    color: var(--text-main);
    font-size: 22px;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
   }

   #topbar-menu {
    gap: 8px;
   }

   @media (min-width: 721px) {
    #topbar-menu {
     display: flex !important;
    }
   }

   @media (max-width: 720px) {
    #topbar-menu {
     display: none;
    }

    #topbar-menu.open {
     display: flex;
    }
   }

   @media (max-width: 720px) {
    .mobile-menu-btn {
     display: block;
    }

    #topbar-menu {
     position: absolute;
     top: var(--topbar-height);
     right: 0;
     background: var(--panel-alt);
     border-left: 1px solid var(--topbar-border);
     border-bottom: 1px solid var(--topbar-border);
     padding: 12px;
     display: none;
     flex-direction: column;
     width: 180px;
     z-index: 999;
    }

    #topbar-menu.open {
     display: flex;
    }

    header {
     position: relative;
     z-index: 9999;
    }
   }

   @media (max-width: 720px) {

    .draw-toolbar,
    .topology-toolbar {
     position: absolute;
     top: auto;
     bottom: auto;
     left: 10px !important;
     right: auto !important;
     width: auto;
     display: flex !important;
     gap: 6px;
     padding: 8px;
    }

    .draw-toolbar {
     top: 10px !important;
    }

    .topology-toolbar {
     top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
    }

    .canvas-hint {
     top: calc(10px + 120px);
    }
   }

   .icon-picker-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 10000;
    justify-content: center;
    align-items: center;
   }

   .icon-picker-modal.active {
    display: flex;
   }

   .icon-picker-content {
    background: var(--panel);
    border-radius: 12px;
    width: 90%;
    max-width: 800px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    border: 1px solid var(--edge-main);
   }

   .icon-picker-header {
    padding: 20px;
    border-bottom: 1px solid var(--edge-main);
   }

   .icon-picker-header h3 {
    margin: 0 0 15px 0;
    color: var(--text-main);
   }

   .icon-picker-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
   }

   .icon-picker-tab {
    padding: 8px 16px;
    background: var(--panel-alt);
    border: 1px solid var(--edge-main);
    border-radius: 6px;
    cursor: pointer;
    color: var(--text-soft);
    font-size: 14px;
    transition: all 0.2s;
   }

   .icon-picker-tab:hover {
    background: var(--accent);
    color: var(--bg);
   }

   .icon-picker-tab.active {
    background: var(--accent);
    color: var(--bg);
    border-color: var(--accent);
   }

   .icon-picker-search {
    width: 100%;
    padding: 10px 15px;
    background: var(--panel-alt);
    border: 1px solid var(--edge-main);
    border-radius: 6px;
    color: var(--text-main);
    font-size: 14px;
   }

   .icon-picker-search::placeholder {
    color: var(--text-soft);
   }

   .icon-picker-body {
    padding: 20px;
    overflow-y: auto;
    flex: 1;
   }

   .icon-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 10px;
   }

   .icon-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 15px 10px;
    background: var(--panel-alt);
    border: 1px solid var(--edge-main);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
   }

   .icon-item:hover {
    background: var(--accent);
    border-color: var(--accent);
    transform: scale(1.05);
   }

   .icon-item svg {
    width: 32px;
    height: 32px;
    fill: var(--text-main);
   }

   .icon-item:hover svg {
    fill: var(--bg);
   }

   .icon-item-name {
    margin-top: 8px;
    font-size: 10px;
    color: var(--text-soft);
    text-align: center;
    word-break: break-word;
   }

   .icon-item:hover .icon-item-name {
    color: var(--bg);
   }

   .icon-picker-loading {
    text-align: center;
    padding: 40px;
    color: var(--text-soft);
   }

   .icon-picker-footer {
    padding: 15px 20px;
    border-top: 1px solid var(--edge-main);
    display: flex;
    justify-content: flex-end;
   }

   .icon-btn-cancel {
    padding: 8px 20px;
    background: var(--panel-alt);
    color: var(--text-main);
    border: 1px solid var(--edge-main);
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
   }

   .icon-btn-cancel:hover {
    background: var(--edge-main);
   }

   .icon-badge {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 4px 8px;
    background: var(--panel-alt);
    border-radius: 4px;
    font-size: 12px;
    margin: 2px;
   }

   .icon-badge svg {
    width: 16px;
    height: 16px;
    fill: currentColor;
   }

   .pick-icon-btn {
    padding: 6px 12px;
    background: var(--accent);
    color: var(--bg);
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    margin-top: 8px;
    width: 100%;
   }

   .pick-icon-btn:hover {
    opacity: 0.9;
   }

   @media (max-width: 768px) {
    .icon-picker-content {
     width: 95%;
     max-height: 90vh;
    }
   }
  </style>
 </head>
 <body style="
      background: radial-gradient(
      circle at center top,
      rgb(30, 37, 50) 0px,
      rgb(5, 6, 8) 70%
      );
      ">
  <div class="icon-picker-modal" id="icon-picker-modal">
   <div class="icon-picker-content">
    <div class="icon-picker-header">
     <h3>Select Icon</h3>
     <div class="icon-picker-tabs">
      <button class="icon-picker-tab active" data-library="mdi">MDI</button>
      <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
      <button class="icon-picker-tab" data-library="selfhst">Selfh.st</button>
     </div>
     <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons...">
    </div>
    <div class="icon-picker-body" id="icon-picker-body">
     <div class="icon-picker-loading">Loading icons...</div>
    </div>
    <div class="icon-picker-footer">
     <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
    </div>
   </div>
  </div>

  <div class="modal" id="edit-modal">
   <div class="modal-content">
    <h3 id="modal-title">Edit Name</h3>
    <input type="text" id="modal-input">
    <div class="modal-buttons">
     <button class="btn-cancel" id="modal-cancel">Cancel</button>
     <button class="btn-save" id="modal-save">Save</button>
    </div>
   </div>
  </div>
  <div class="modal confirm-modal" id="confirm-modal">
   <div class="modal-content">
    <h3>Confirm</h3>
    <p id="confirm-message"> Are you sure you want to delete this line? </p>
    <div class="modal-buttons">
     <button class="btn-cancel" id="confirm-cancel">Cancel</button>
     <button class="btn-delete" id="confirm-delete">Delete</button>
    </div>
   </div>
  </div>
  <div class="modal" id="save-info-modal">
   <div class="modal-content">
    <h3>Why do I need to save?</h3>
    <p> Browsers are not allowed to overwrite local files automatically. When you click <strong>Save File</strong>, this page generates a new updated HTML file that contains all of your changes. Replace your old file with the new one to keep your edits. </p>
    <p style="
               margin-top: 12px;
               padding-top: 12px;
               border-top: 1px solid var(--edge-main);
               ">
     <strong>üîí Encryption:</strong> Check the "Encrypt" box before saving to password protect your data. You'll need the password to open the file later. No recovery possible!!
    </p>
    <div class="modal-buttons">
     <button class="btn-cancel" id="save-info-close">Close</button>
    </div>
   </div>
  </div>
  <div class="modal" id="settings-modal">
   <div class="modal-content" style="max-width: 400px">
    <h3>Page Settings</h3>
    <details class="style-section" open="">
     <summary>Background</summary>
     <div class="style-content">
      <div class="style-row">
       <label>Solid Color</label>
       <input type="color" id="page-bg-color" value="#050608">
      </div>
      <p style="
                     margin-top: 4px;
                     font-size: 12px;
                     color: var(--text-soft);
                     "> Change to apply a flat background color. </p>
     </div>
    </details>
    <details class="style-section" open="">
     <summary>Top Bar</summary>
     <div class="style-content">
      <div class="style-row">
       <label>Background</label>
       <input type="color" id="topbar-bg-color" value="#0b0e13">
      </div>
      <div class="style-row">
       <label>Border</label>
       <input type="color" id="topbar-border-color" value="#1f2533">
      </div>
     </div>
    </details>
    <details class="style-section" open="">
     <summary>Theme Colors</summary>
     <div class="style-content">
      <div class="style-row">
       <label>Panel</label>
       <input type="color" id="panel-color" value="#0b0e13">
      </div>
      <div class="style-row">
       <label>Panel Alt</label>
       <input type="color" id="panel-alt-color" value="#10141b">
      </div>
      <div class="style-row">
       <label>Accent</label>
       <input type="color" id="accent-color" value="#4fd1c5">
      </div>
      <div class="style-row">
       <label>Danger</label>
       <input type="color" id="danger-color" value="#f56565">
      </div>
      <div class="style-row">
       <label>Text Main</label>
       <input type="color" id="text-main-color" value="#e2e8f0">
      </div>
      <div class="style-row">
       <label>Text Soft</label>
       <input type="color" id="text-soft-color" value="#94a3b8">
      </div>
     </div>
    </details>
    <details class="style-section" open="">
     <summary>Import / Export Data</summary>
     <div class="style-content">
      <p style="
                     margin-bottom: 12px;
                     font-size: 13px;
                     color: var(--text-soft);
                     "> Export/Import your data to upgrade/downgrade versions of The One File. </p>
      <button id="export-data-btn" style="
                     width: 100%;
                     margin-bottom: 10px;
                     padding: 10px;
                     background: var(--accent);
                     color: var(--bg);
                     border: none;
                     border-radius: 6px;
                     cursor: pointer;
                     font-size: 14px;
                     font-weight: 600;
                     "> Export Data (JSON) </button>
      <button id="import-data-btn" style="
                     width: 100%;
                     padding: 10px;
                     background: var(--panel);
                     color: var(--text-main);
                     border: 1px solid var(--edge-main);
                     border-radius: 6px;
                     cursor: pointer;
                     font-size: 14px;
                     font-weight: 600;
                     "> Import Data (JSON) </button>
      <input type="file" id="import-data-file" accept=".json" style="display: none">
     </div>
    </details>
    <div class="modal-buttons">
     <button class="btn-cancel" id="settings-close">Close</button>
    </div>
   </div>
  </div>
  <div class="modal" id="add-node-modal">
   <div class="modal-content">
    <h3>Add New Node</h3>
    <label style="
               display: block;
               margin-bottom: 4px;
               color: var(--text-soft);
               font-size: 13px;
               ">Name</label>
    <input type="text" id="new-node-name" placeholder="e.g. web-server">
    <label style="
               display: block;
               margin-bottom: 4px;
               color: var(--text-soft);
               font-size: 13px;
               ">IP / Subtitle</label>
    <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
    <label style="
               display: block;
               margin-bottom: 4px;
               color: var(--text-soft);
               font-size: 13px;
               ">Tags (comma separated)</label>
    <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
    <label style="
               display: block;
               margin-bottom: 4px;
               color: var(--text-soft);
               font-size: 13px;
               ">Shape</label>
    <select id="new-node-shape">
     <optgroup label="Basic Shapes">
      <option value="circle">Circle</option>
      <option value="square">Square</option>
      <option value="rectangle">Rectangle</option>
      <option value="triangle">Triangle</option>
      <option value="hexagon">Hexagon</option>
      <option value="diamond">Diamond</option>
      <option value="star">Star</option>
      <option value="stop-sign">Stop Sign</option>
     </optgroup>
     <optgroup label="Network Equipment">
      <option value="server">Server</option>
      <option value="pc">PC / Desktop</option>
      <option value="laptop">Laptop</option>
      <option value="phone">Phone / Mobile</option>
      <option value="router">Router</option>
      <option value="switch">Switch</option>
      <option value="firewall">Firewall</option>
      <option value="cloud">Cloud</option>
      <option value="database">Database</option>
      <option value="printer">Printer</option>
     </optgroup>
    </select>
    <button class="pick-icon-btn" id="pick-node-icon-btn">üé® Or Pick an Icon</button>
    <div id="selected-node-icon" style="margin-top: 10px; display: none;">
     <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
     <div class="icon-badge" id="selected-node-icon-preview"></div>
    </div>
    <div class="modal-buttons">
     <button class="btn-cancel" id="add-node-cancel">Cancel</button>
     <button class="btn-save" id="add-node-save">Add Node</button>
    </div>
   </div>
  </div>
  <div class="modal confirm-modal" id="clear-all-modal">
   <div class="modal-content">
    <h3>Clear All Nodes</h3>
    <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
    <div class="modal-buttons">
     <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
     <button class="btn-delete" id="clear-all-confirm"> Clear Everything </button>
    </div>
   </div>
  </div>
  <header>
   <div class="title-block">
    <h1 id="page-title" class="editable-page-title">The One File: The Networkening</h1>
    <div class="save-row">
     <button id="save-file-btn" class="save-btn" type="button"> Save File </button>
     <label style="
                  display: flex;
                  align-items: center;
                  gap: 4px;
                  font-size: 12px;
                  color: var(--text-soft);
                  cursor: pointer;
                  user-select: none;
                  ">
      <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
      <span title="Encrypt data with password">Encrypt</span>
     </label>
     <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
    </div>
   </div>
   <div id="topbar-menu">
    <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)"> + Node </button>
    <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="
               padding: 6px 12px;
               background: var(--panel);
               color: var(--text-main);
               border: 1px solid var(--edge-main);
               border-radius: 6px;
               cursor: pointer;
               font-size: 14px;
               font-weight: 600;
               "> üì∑ PNG </button>
    <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="
               padding: 6px 12px;
               background: var(--panel);
               color: var(--text-main);
               border: 1px solid var(--edge-main);
               border-radius: 6px;
               cursor: pointer;
               font-size: 14px;
               font-weight: 600;
               "> üìÑ SVG </button>
    <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
    <button id="clear-all-btn" title="Clear all nodes" style="
               padding: 6px 12px;
               background: var(--danger);
               color: #fff;
               border: none;
               border-radius: 6px;
               cursor: pointer;
               font-size: 14px;
               font-weight: 600;
               "> Clear All </button>
   </div>
   <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
  </header>
  <main>
   <section class="topology-panel">
    <div class="draw-toolbar" id="draw-toolbar">
     <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
     <input type="color" id="draw-color" value="#f97316" title="Line color">
     <select id="draw-style" title="Line style">
      <option value="solid">Solid</option>
      <option value="dashed">Dashed</option>
      <option value="dotted">Dotted</option>
     </select>
     <select id="draw-arrow" title="Arrow direction">
      <option value="none">No arrows</option>
      <option value="forward">‚Üí Right</option>
      <option value="backward">‚Üê Left</option>
      <option value="both">‚Üî Both</option>
     </select>
     <button id="draw-undo" style="display: none" title="Undo last point"> Undo </button>
    </div>
    <div class="topology-toolbar" id="topology-toolbar" style="display: none">
     <label for="add-line-select">Add line to:</label>
     <select id="add-line-select">
      <option value=""></option>
     </select>
     <input type="color" id="add-line-color" value="#475569" title="Line color" style="
                  width: 30px;
                  height: 24px;
                  border: 1px solid var(--edge-main);
                  border-radius: 4px;
                  cursor: pointer;
                  background: transparent;
                  padding: 0;
                  ">
     <select id="add-line-direction" title="Line direction">
      <option value="none">No arrows</option>
      <option value="forward">‚Üí Forward</option>
      <option value="backward">‚Üê Backward</option>
      <option value="both">‚Üî Both</option>
     </select>
     <button id="add-line-btn">Add</button>
    </div>
    <div class="canvas-hint" id="canvas-hint"> Scroll to zoom ‚Ä¢ Drag empty space to pan ‚Ä¢ Hold Space + drag </div>
    <div class="legend-container" id="edge-legend" style="display: none">
     <div class="legend-title">Line Legend</div>
    </div>
    <div class="canvas-viewport" id="canvas-viewport">
     <svg id="map" viewBox="0 0 4000 3000" style="">
      <defs>
       <marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path>
       </marker>
       <marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth">
        <path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path>
       </marker>
      </defs>
      <rect x="100" y="100" width="3800" height="2800" fill="none" stroke="rgba(71, 85, 105, 0.3)" stroke-width="2" stroke-dasharray="10 5" rx="8"></rect>
     </svg>
    </div>
    <div class="minimap-container" id="minimap-container">
     <svg id="minimap" viewBox="0 0 4000 3000">
      <rect class="minimap-viewport" id="minimap-viewport" x="0" y="0" width="4000" height="3000"></rect>
     </svg>
    </div>
    <div class="zoom-toolbar" id="zoom-toolbar">
     <button id="zoom-in-btn" title="Zoom in">+</button>
     <div class="zoom-level" id="zoom-level">100%</div>
     <button id="zoom-out-btn" title="Zoom out">-</button>
     <div class="divider"></div>
     <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
     <button id="zoom-reset-btn" title="Reset view">R</button>
    </div>
   </section>
   <aside class="details-panel" id="details-panel">
    <div id="node-panel" style="display: none">
     <div class="details-name editable-text" id="node-name"></div>
     <div class="details-ip editable-text" id="node-ip"></div>
     <div class="details-role" id="node-role"></div>
     <div class="badge-row" id="node-tags">
      <span class="badge" style="cursor: pointer; position: relative">
       <span></span>
       <span style="opacity: 0.6; margin-left: 4px; font-size: 10px"> ‚úï</span>
      </span>
      <span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed">+ Add</span>
     </div>
     <div style="margin-top: 10px; display: flex; gap: 8px">
      <input type="text" id="new-tag-input" placeholder="Add tag..." style="
                     flex: 1;
                     padding: 8px 12px;
                     background: var(--panel);
                     border: 1px solid var(--edge-main);
                     border-radius: 6px;
                     color: var(--text-main);
                     font-size: clamp(14px, 1.6vw, 18px);
                     ">
      <button id="add-tag-btn" style="
                     padding: 8px 16px;
                     background: var(--accent);
                     color: var(--bg);
                     border: none;
                     border-radius: 6px;
                     cursor: pointer;
                     font-size: clamp(14px, 1.6vw, 18px);
                     font-weight: 600;
                     "> Add </button>
     </div>
     <button class="pick-icon-btn" id="pick-tag-icon-btn">üé® Add Icon Tag</button>
     <div class="section-label">Size</div>
     <div class="size-controls">
      <label>Size:</label>
      <input type="range" id="size-slider" min="20" max="200" value="55">
      <span id="size-value">55</span>
      <button id="reset-size">Reset</button>
     </div>
     <details class="style-section">
      <summary>Styling</summary>
      <div class="style-content">
       <div class="style-row">
        <label>Screen:</label>
        <select id="style-scope">
         <option value="all">All</option>
         <option value="desktop">Desktop</option>
         <option value="tablet">Tablet</option>
         <option value="mobile">Mobile</option>
         <option value="fold">Fold</option>
        </select>
       </div>
       <div class="style-row">
        <label>Shape:</label>
        <select id="shape-select">
         <optgroup label="Basic Shapes">
          <option value="circle">Circle</option>
          <option value="square">Square</option>
          <option value="rectangle">Rectangle</option>
          <option value="triangle">Triangle</option>
          <option value="hexagon">Hexagon</option>
          <option value="diamond">Diamond</option>
          <option value="star">Star</option>
          <option value="stop-sign">Stop Sign</option>
         </optgroup>
         <optgroup label="Network Equipment">
          <option value="server">Server</option>
          <option value="pc">PC / Desktop</option>
          <option value="laptop">Laptop</option>
          <option value="phone">Phone / Mobile</option>
          <option value="router">Router</option>
          <option value="switch">Switch</option>
          <option value="firewall">Firewall</option>
          <option value="cloud">Cloud</option>
          <option value="database">Database</option>
          <option value="printer">Printer</option>
         </optgroup>
        </select>
       </div>
       <button class="pick-icon-btn" id="pick-shape-icon-btn">üé® Or Pick an Icon</button>
       <div class="style-row">
        <label>Circle Color:</label>
        <input type="color" id="circle-color" value="#1e293b">
       </div>
       <div class="style-row">
        <label>Title Color:</label>
        <input type="color" id="title-color" value="#e2e8f0">
       </div>
       <div class="style-row">
        <label>Title Font:</label>
        <select id="title-font">
         <option value="system-ui, sans-serif"> System UI </option>
         <option value="monospace">Monospace</option>
         <option value="serif">Serif</option>
         <option value="cursive">Cursive</option>
         <option value="'Courier New', monospace"> Courier </option>
         <option value="Arial, sans-serif">Arial</option>
         <option value="'Times New Roman', serif"> Times </option>
        </select>
       </div>
       <div class="style-row">
        <label>Title Size:</label>
        <input type="number" id="title-size" min="8" max="100" value="18">
       </div>
       <div class="style-row">
        <label>Sub Color:</label>
        <input type="color" id="sub-color" value="#94a3b8">
       </div>
       <div class="style-row">
        <label>Sub Font:</label>
        <select id="sub-font">
         <option value="system-ui, sans-serif"> System UI </option>
         <option value="monospace">Monospace</option>
         <option value="serif">Serif</option>
         <option value="cursive">Cursive</option>
         <option value="'Courier New', monospace"> Courier </option>
         <option value="Arial, sans-serif">Arial</option>
         <option value="'Times New Roman', serif"> Times </option>
        </select>
       </div>
       <div class="style-row">
        <label>Sub Size:</label>
        <input type="number" id="sub-size" min="6" max="80" value="13">
       </div>
       <div style="
                        margin-top: 12px;
                        padding-top: 10px;
                        border-top: 1px solid var(--edge-main);
                        ">
        <div style="
                           font-size: 12px;
                           color: var(--text-soft);
                           margin-bottom: 8px;
                           text-transform: uppercase;
                           "> Text Position </div>
        <div class="style-row">
         <label>Name Y:</label>
         <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
        </div>
        <div class="style-row">
         <label>Name X:</label>
         <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
        </div>
        <div class="style-row">
         <label>IP Y:</label>
         <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
        </div>
        <div class="style-row">
         <label>IP X:</label>
         <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
        </div>
       </div>
       <button id="reset-styles" style="
                        width: 100%;
                        margin-top: 10px;
                        padding: 8px;
                        background: var(--panel);
                        color: var(--text-main);
                        border: 1px solid var(--edge-main);
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: clamp(13px, 1.5vw, 17px);
                        "> Reset Styles </button>
      </div>
     </details>
     <div class="section-label">Notes</div>
     <ul class="list" id="node-notes"></ul>
     <div style="margin-top: 10px; display: flex; gap: 8px">
      <input type="text" id="new-note-input" placeholder="Type new note..." style="
                     flex: 1;
                     padding: 8px 12px;
                     background: var(--panel);
                     border: 1px solid var(--edge-main);
                     border-radius: 6px;
                     color: var(--text-main);
                     font-size: clamp(14px, 1.6vw, 18px);
                     ">
      <button id="add-note-btn" style="
                     padding: 8px 16px;
                     background: var(--accent);
                     color: var(--bg);
                     border: none;
                     border-radius: 6px;
                     cursor: pointer;
                     font-size: clamp(14px, 1.6vw, 18px);
                     font-weight: 600;
                     "> Add </button>
     </div>
     <button id="delete-node-btn" style="
                  margin-top: 15px;
                  padding: 10px 16px;
                  background: var(--danger);
                  color: rgb(255, 255, 255);
                  border: none;
                  border-radius: 6px;
                  cursor: pointer;
                  font-size: clamp(14px, 1.6vw, 18px);
                  font-weight: 600;
                  width: 100%;
                  "> Delete Node </button>
    </div>
    <div id="edge-panel" style="display: none">
     <div class="details-name" id="edge-title">Custom line</div>
     <div class="style-row" style="margin-top: 10px">
      <label>Width:</label>
      <input type="number" id="edge-width" min="1" max="20" value="4">
     </div>
     <div class="style-row">
      <label>Color:</label>
      <input type="color" id="edge-color" value="#475569">
     </div>
     <div class="style-row">
      <label>Line Style:</label>
      <select id="edge-line-style">
       <option value="solid">Solid</option>
       <option value="dashed">Dashed</option>
       <option value="dotted">Dotted</option>
      </select>
     </div>
     <div class="style-row">
      <label>Direction:</label>
      <select id="edge-direction">
       <option value="none">No arrows</option>
       <option value="forward">‚Üí Forward</option>
       <option value="backward">‚Üê Backward</option>
       <option value="both">‚Üî Bidirectional</option>
      </select>
     </div>
     <div class="section-label">Line Notes</div>
     <ul class="list" id="edge-notes"></ul>
     <div style="margin-top: 10px; display: flex; gap: 8px">
      <input type="text" id="new-edge-note" placeholder="Add note..." style="
                     flex: 1;
                     padding: 8px 12px;
                     background: var(--panel);
                     border: 1px solid var(--edge-main);
                     border-radius: 6px;
                     color: var(--text-main);
                     font-size: clamp(14px, 1.6vw, 18px);
                     ">
      <button id="add-edge-note" style="
                     padding: 8px 16px;
                     background: var(--accent);
                     color: var(--bg);
                     border: none;
                     border-radius: 6px;
                     cursor: pointer;
                     font-size: clamp(14px, 1.6vw, 18px);
                     font-weight: 600;
                     "> Add </button>
     </div>
     <button id="delete-edge" style="
                  margin-top: 15px;
                  padding: 10px 16px;
                  background: var(--danger);
                  color: #fff;
                  border: none;
                  border-radius: 6px;
                  cursor: pointer;
                  font-size: clamp(14px, 1.6vw, 18px);
                  font-weight: 600;
                  "> Delete Line </button>
    </div>
    <details class="style-section" open="">
     <summary>Page Layout</summary>
     <div class="style-content">
      <div class="style-row">
       <label>Topbar Height</label>
       <input type="range" id="topbar-height" min="40" max="100" value="52" style="flex: 1">
       <span id="topbar-height-val" style="min-width: 35px; text-align: right">100px</span>
      </div>
      <div class="style-row">
       <label>Sidebar Width</label>
       <input type="range" id="sidebar-width" min="200" max="600" value="350" style="flex: 1">
       <span id="sidebar-width-val" style="min-width: 45px; text-align: right">435px</span>
      </div>
      <div class="style-row">
       <label>Mobile Footer Height</label>
       <input type="range" id="mobile-footer-height" min="20" max="70" value="40" style="flex: 1">
       <span id="mobile-footer-height-val" style="min-width: 45px; text-align: right">20%</span>
      </div>
     </div>
    </details>
   </aside>
  </main>
  <script id="nodes-json" type="application/json">
   {}
  </script>
  <script id="topology-state" type="application/json">
   {
    "nodeData": {},
    "edgeData": {
     "list": []
    },
    "edgeLegend": {},
    "nodePositions": {},
    "nodeSizes": {},
    "nodeStyles": {},
    "iconCache": {},
    "page": {
     "title": "The One File: The Networkening",
     "background": "",
     "topbarBg": "rgba(9, 12, 20, 0.9)",
     "topbarBorder": "#1f2533",
     "panel": "#0b0e13",
     "panelAlt": "#10141b",
     "accent": "#4fd1c5",
     "danger": "#f56565",
     "textMain": "#e2e8f0",
     "textSoft": "#94a3b8",
     "topbarHeight": 100,
     "sidebarWidth": 435,
     "mobileFooterHeight": 20,
     "sidebarCollapsed": false
    },
    "canvas": {
     "zoom": 1,
     "panX": 0,
     "panY": 0
    }
   }
  </script>
  <script>
   const IconLibrary = {
    libraries: {
     mdi: {
      name: 'Material Design Icons',
      cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
      metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
      icons: []
     },
     simple: {
      name: 'Simple Icons',
      cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
      icons: []
     },
     selfhst: {
      name: 'Selfh.st',
      cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
      apiUrl: 'https://api.github.com/repos/selfhst/icons/contents/svg',
      icons: []
     }
    },
    currentLibrary: 'mdi',
    iconCache: {},
    
    async loadLibrary(library) {
     return [];
    },
    
    async getIcon(library, name) {
     const cacheKey = `${library}-${name}`;
     
     if (this.iconCache[cacheKey]) {
      return this.iconCache[cacheKey];
     }
     
     const cached = localStorage.getItem(`icon-${cacheKey}`);
     if (cached) {
      this.iconCache[cacheKey] = cached;
      return cached;
     }
     
     const lib = this.libraries[library];
     const url = `${lib.cdnBase}${name}.svg`;
     
     try {
      const response = await fetch(url);
      const svg = await response.text();
      
      this.iconCache[cacheKey] = svg;
      localStorage.setItem(`icon-${cacheKey}`, svg);
      
      return svg;
     } catch (error) {
      console.error(`Failed to fetch icon ${cacheKey}:`, error);
      return null;
     }
    },
    
    searchIcons(library, query) {
     const lib = this.libraries[library];
     if (!lib.icons.length) return [];
     
     const q = query.toLowerCase();
     return lib.icons.filter(icon => 
      icon.name.toLowerCase().includes(q) ||
      icon.keywords.some(k => k.toLowerCase().includes(q))
     ).slice(0, 100);
    }
   };
   
   let iconPickerCallback = null;
   
   function openIconPicker(callback) {
    iconPickerCallback = callback;
    const modal = document.getElementById('icon-picker-modal');
    modal.classList.add('active');
    
    const searchInput = document.getElementById('icon-search');
    searchInput.style.display = 'none';
    
    loadIconsForCurrentLibrary();
   }
   
   function closeIconPicker() {
    const modal = document.getElementById('icon-picker-modal');
    modal.classList.remove('active');
    iconPickerCallback = null;
   }
   
   async function loadIconsForCurrentLibrary() {
    const body = document.getElementById('icon-picker-body');
    
    const libNames = {
     mdi: 'MDI (Material Design Icons)',
     simple: 'Simple Icons',
     selfhst: 'Selfh.st'
    };
    
    body.innerHTML = `
     <div style="text-align: center; padding: 20px;">
      <p style="color: var(--text-soft); margin-bottom: 15px;">
       Enter icon name for ${libNames[IconLibrary.currentLibrary]}:
      </p>
      <input 
       type="text" 
       id="icon-input-field" 
       placeholder="e.g. server, jellyfin, docker, home, spigotmc, opengl"
       style="width: 100%; max-width: 400px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"
      >
      <div id="icon-preview" style="min-height: 150px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 15px;">
       <div style="color: var(--text-soft); font-size: 14px;">Type an icon name to preview</div>
      </div>
     </div>
    `;
    
    let previewTimeout;
    const input = document.getElementById('icon-input-field');
	input.addEventListener('input', () => {
    input.value = input.value.toLowerCase();
    });
    const preview = document.getElementById('icon-preview');
    
    input.addEventListener('input', (e) => {
     clearTimeout(previewTimeout);
     const iconName = e.target.value.trim();
     
     if (!iconName) {
      preview.innerHTML = '<div style="color: var(--text-soft); font-size: 14px;">Type an icon name to preview</div>';
      return;
     }
     
     preview.innerHTML = '<div style="color: var(--text-soft); font-size: 14px;">Loading...</div>';
     
     previewTimeout = setTimeout(async () => {
      const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, iconName);
      
      if (svg) {
       const parser = new DOMParser();
       const doc = parser.parseFromString(svg, 'image/svg+xml');
       const svgEl = doc.querySelector('svg');
       
       if (svgEl) {
        svgEl.setAttribute('width', '64');
        svgEl.setAttribute('height', '64');
        svgEl.style.fill = 'var(--text-main)';
        
        preview.innerHTML = '';
        preview.appendChild(svgEl);
        
        const nameDiv = document.createElement('div');
        nameDiv.textContent = iconName;
        nameDiv.style.color = 'var(--text-main)';
        nameDiv.style.fontSize = '16px';
        nameDiv.style.marginTop = '10px';
        preview.appendChild(nameDiv);
        
        const useBtn = document.createElement('button');
        useBtn.textContent = 'Use This Icon';
        useBtn.style.cssText = 'padding: 10px 20px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; margin-top: 15px;';
        useBtn.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: IconLibrary.currentLibrary,
           name: iconName,
           svg: svg
          });
         }
         closeIconPicker();
        });
        preview.appendChild(useBtn);
       } else {
        preview.innerHTML = '<div style="color: var(--danger);">Invalid SVG</div>';
       }
      } else {
       preview.innerHTML = `<div style="color: var(--danger);">Icon "${iconName}" not found</div>`;
      }
     }, 500);
    });
    
    input.focus();
   }
   
   async function displayIcons(icons) {
    const body = document.getElementById('icon-picker-body');
    const grid = document.createElement('div');
    grid.className = 'icon-grid';
    
    for (const icon of icons) {
      const item = document.createElement('div');
      item.className = 'icon-item';
      
      const svg = await IconLibrary.getIcon(icon.library, icon.name);
      if (svg) {
       const parser = new DOMParser();
       const doc = parser.parseFromString(svg, 'image/svg+xml');
       const svgEl = doc.querySelector('svg');
       if (svgEl) {
        item.innerHTML = svgEl.outerHTML;
       }
      } else {
       item.innerHTML = '<svg width="32" height="32"><rect width="32" height="32" fill="currentColor"/></svg>';
      }
      
      const name = document.createElement('div');
      name.className = 'icon-item-name';
      name.textContent = icon.name;
      item.appendChild(name);
      
      item.addEventListener('click', () => {
       if (iconPickerCallback) {
        iconPickerCallback({
         library: icon.library,
         name: icon.name,
         svg: svg
        });
       }
       closeIconPicker();
      });
      
      grid.appendChild(item);
    }
    
    body.innerHTML = '';
    body.appendChild(grid);
   }
   
   window.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.icon-picker-tab').forEach(tab => {
     tab.addEventListener('click', () => {
      document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      IconLibrary.currentLibrary = tab.dataset.library;
      loadIconsForCurrentLibrary();
     });
    });
    
    document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
    
    document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
     if (e.target.id === 'icon-picker-modal') {
      closeIconPicker();
     }
    });
   });
   
   const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
   let currentNodeId = "host";
   let currentEdgeId = null;
   let currentStyleScope = "all";
   let NODE_DATA = {};
   let EDGE_DATA = {
    list: []
   };
   let EDGE_LEGEND = {};
   let savedPositions = {};
   let savedSizes = {};
   let savedStyles = {};
   let legendCollapsed = false;
   let legendMiniBtn = null;

   function ensureLegendMiniButton() {
    if (legendMiniBtn) return legendMiniBtn;
    const panel = document.querySelector(".topology-panel");
    if (!panel) return null;
    const btn = document.createElement("button");
    btn.type = "button";
    btn.id = "edge-legend-mini";
    btn.className = "legend-mini-btn";
    btn.textContent = "Legend";
    btn.addEventListener("click", (e) => {
     e.stopPropagation();
     legendCollapsed = false;
     updateLegendVisibility();
    });
    panel.appendChild(btn);
    legendMiniBtn = btn;
    return btn;
   }

   function updateToolbarStack() {
    if (window.innerWidth > 720) return;
    const draw = document.getElementById("draw-toolbar");
    const topo = document.getElementById("topology-toolbar");
    if (!draw || !topo) return;
    const h = draw.getBoundingClientRect().height;
    document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
   }
   window.addEventListener("resize", updateToolbarStack);
   window.addEventListener("DOMContentLoaded", updateToolbarStack);
   updateToolbarStack();

   function updateLegendVisibility() {
    const legend = document.getElementById("edge-legend");
    const mini = ensureLegendMiniButton();
    if (!legend || !mini) return;
    const hasItems = legend.querySelectorAll(".legend-item").length > 0;
    if (!hasItems) {
     legend.style.display = "none";
     mini.style.display = "none";
     return;
    }
    if (legendCollapsed) {
     legend.style.display = "none";
     mini.style.display = "inline-flex";
    } else {
     legend.style.display = "flex";
     mini.style.display = "none";
    }
   }
   const DEFAULT_PAGE_STATE = {
    title: "The One File: The Networkening",
    background: "",
    topbarBg: "rgba(9, 12, 20, 0.9)",
    topbarBorder: "#1f2533",
    panel: "#0b0e13",
    panelAlt: "#10141b",
    accent: "#4fd1c5",
    danger: "#f56565",
    textMain: "#e2e8f0",
    textSoft: "#94a3b8",
    topbarHeight: 52,
    sidebarWidth: 350,
    mobileFooterHeight: 40,
    sidebarCollapsed: false,
   };
   let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
   const CANVAS_WIDTH = 4000;
   const CANVAS_HEIGHT = 3000;
   const CANVAS_PADDING = 100;
   let canvasState = {
    zoom: 1,
    panX: 0,
    panY: 0,
    minZoom: 0.25,
    maxZoom: 4,
    isPanning: false,
    panStartX: 0,
    panStartY: 0,
    spacePressed: false,
   };

   function getViewBox() {
    const viewWidth = CANVAS_WIDTH / canvasState.zoom;
    const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
    return {
     x: canvasState.panX,
     y: canvasState.panY,
     width: viewWidth,
     height: viewHeight,
    };
   }

   function updateViewBox() {
    const svg = document.getElementById("map");
    const vb = getViewBox();
    svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
    const zoomLevel = document.getElementById("zoom-level");
    if (zoomLevel) {
     zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
    }
    updateMinimap();
   }

   function updateMinimap() {
    const minimapViewport = document.getElementById("minimap-viewport");
    const minimapSvg = document.getElementById("minimap");
    if (!minimapViewport || !minimapSvg) return;
    const vb = getViewBox();
    minimapViewport.setAttribute("x", vb.x);
    minimapViewport.setAttribute("y", vb.y);
    minimapViewport.setAttribute("width", vb.width);
    minimapViewport.setAttribute("height", vb.height);
    const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
    minimapNodes.forEach((n) => n.remove());
    const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
    minimapEdges.forEach((e) => e.remove());
    EDGE_DATA.list.forEach((edge) => {
     if (edge.type === "custom") return;
     const p1 = savedPositions[edge.from];
     const p2 = savedPositions[edge.to];
     if (!p1 || !p2) return;
     const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
     line.setAttribute("x1", p1.x);
     line.setAttribute("y1", p1.y);
     line.setAttribute("x2", p2.x);
     line.setAttribute("y2", p2.y);
     line.classList.add("minimap-edge");
     minimapSvg.insertBefore(line, minimapViewport);
    });
    Object.entries(savedPositions).forEach(([id, pos]) => {
     const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
     circle.setAttribute("cx", pos.x);
     circle.setAttribute("cy", pos.y);
     circle.setAttribute("r", 40);
     circle.classList.add("minimap-node");
     minimapSvg.insertBefore(circle, minimapViewport);
    });
   }

   function zoomTo(newZoom, centerX, centerY) {
    const oldZoom = canvasState.zoom;
    newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
    if (centerX !== undefined && centerY !== undefined) {
     const oldWidth = CANVAS_WIDTH / oldZoom;
     const oldHeight = CANVAS_HEIGHT / oldZoom;
     const newWidth = CANVAS_WIDTH / newZoom;
     const newHeight = CANVAS_HEIGHT / newZoom;
     const pointX = canvasState.panX + centerX * oldWidth;
     const pointY = canvasState.panY + centerY * oldHeight;
     canvasState.panX = pointX - centerX * newWidth;
     canvasState.panY = pointY - centerY * newHeight;
    }
    canvasState.zoom = newZoom;
    constrainPan();
    updateViewBox();
   }

   function constrainPan() {
    const viewWidth = CANVAS_WIDTH / canvasState.zoom;
    const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
    const minVisiblePortion = 0.1;
    const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
    const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
    const minPanX = -viewWidth * (1 - minVisiblePortion);
    const minPanY = -viewHeight * (1 - minVisiblePortion);
    canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
    canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
   }

   function fitToContent() {
    const positions = Object.values(savedPositions);
    if (positions.length === 0) {
     resetView();
     return;
    }
    let minX = Infinity,
     minY = Infinity,
     maxX = -Infinity,
     maxY = -Infinity;
    positions.forEach((pos) => {
     minX = Math.min(minX, pos.x - 100);
     minY = Math.min(minY, pos.y - 100);
     maxX = Math.max(maxX, pos.x + 100);
     maxY = Math.max(maxY, pos.y + 100);
    });
    const contentWidth = maxX - minX + 200;
    const contentHeight = maxY - minY + 200;
    const viewport = document.getElementById("canvas-viewport");
    const vpRect = viewport.getBoundingClientRect();
    const aspectRatio = vpRect.width / vpRect.height;
    const contentAspect = contentWidth / contentHeight;
    let newZoom;
    if (contentAspect > aspectRatio) {
     newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
    } else {
     newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
    }
    newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
    const viewWidth = CANVAS_WIDTH / newZoom;
    const viewHeight = CANVAS_HEIGHT / newZoom;
    canvasState.zoom = newZoom;
    canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
    canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
    constrainPan();
    updateViewBox();
   }

   function resetView() {
    canvasState.zoom = 1;
    canvasState.panX = 0;
    canvasState.panY = 0;
    updateViewBox();
   }
   window.addEventListener("DOMContentLoaded", () => {
    const toggle = document.getElementById("mobile-menu-toggle");
    const menu = document.getElementById("topbar-menu");
    if (!toggle || !menu) return;
    toggle.addEventListener("click", () => {
     menu.classList.toggle("open");
    });
    menu.addEventListener("click", (e) => {
     const target = e.target.closest("a, button");
     if (!target) return;
     if (window.matchMedia("(max-width: 720px)").matches) {
      menu.classList.remove("open");
     }
    });
   });

   function wieldThePower() {
    const root = document.documentElement;
    root.style.setProperty("--panel", PAGE_STATE.panel);
    root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
    root.style.setProperty("--accent", PAGE_STATE.accent);
    root.style.setProperty("--danger", PAGE_STATE.danger);
    root.style.setProperty("--text-main", PAGE_STATE.textMain);
    root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
    root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
    root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
    const topbarHeight = PAGE_STATE.topbarHeight || 52;
    const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
    const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
    root.style.setProperty("--topbar-height", topbarHeight + "px");
    root.style.setProperty("--sidebar-width", sidebarWidth + "px");
    root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
    const topbarHeightInput = document.getElementById("topbar-height");
    const topbarHeightVal = document.getElementById("topbar-height-val");
    const sidebarWidthInput = document.getElementById("sidebar-width");
    const sidebarWidthVal = document.getElementById("sidebar-width-val");
    const mobileFooterHeightInput = document.getElementById("mobile-footer-height", );
    const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val", );
    if (topbarHeightInput) topbarHeightInput.value = topbarHeight;
    if (topbarHeightVal) topbarHeightVal.textContent = topbarHeight + "px";
    if (sidebarWidthInput) sidebarWidthInput.value = sidebarWidth;
    if (sidebarWidthVal) sidebarWidthVal.textContent = sidebarWidth + "px";
    if (mobileFooterHeightInput) mobileFooterHeightInput.value = mobileFooterHeight;
    if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = mobileFooterHeight + "%";
    const mainEl = document.querySelector("main");
    const detailsPanel = document.getElementById("details-panel");
    const sidebarToggle = document.getElementById("sidebar-toggle");
    if (PAGE_STATE.sidebarCollapsed) {
     if (mainEl) mainEl.classList.add("sidebar-collapsed");
     if (detailsPanel) detailsPanel.classList.add("collapsed");
     if (sidebarToggle) {
      sidebarToggle.classList.add("collapsed");
      sidebarToggle.textContent = "‚ñ∂";
     }
    } else {
     if (mainEl) mainEl.classList.remove("sidebar-collapsed");
     if (detailsPanel) detailsPanel.classList.remove("collapsed");
     if (sidebarToggle) {
      sidebarToggle.classList.remove("collapsed");
      sidebarToggle.textContent = "‚óÄ";
     }
    }
    if (PAGE_STATE.background) {
     document.body.style.background = PAGE_STATE.background;
    } else {
     document.body.style.background = "radial-gradient(circle at top, #1e2532 0, #050608 70%)";
    }
    document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
    const titleEl = document.getElementById("page-title");
    if (titleEl) {
     titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
    }
   }
   (async function awakeTheImmortal() {
    let initialState = {};
    let decryptionCancelled = false;
    const stateEl = document.getElementById("topology-state");
    if (stateEl && stateEl.textContent.trim()) {
     try {
      let stateText = stateEl.textContent.trim();
      if (isEncrypted(stateText)) {
       let decrypted = false;
       let attempts = 0;
       const maxAttempts = 3;
       while (!decrypted && attempts < maxAttempts) {
        const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
        if (!password) {
         alert("Decryption cancelled. The file will not be loaded.", );
         decryptionCancelled = true;
         break;
        }
        try {
         stateText = await decryptData(stateText, password);
         decrypted = true;
        } catch (e) {
         attempts++;
         if (attempts < maxAttempts) {
          alert("Incorrect password. Please try again.");
         } else {
          alert("Maximum attempts reached. The file will not be loaded.", );
          decryptionCancelled = true;
         }
        }
       }
       if (!decrypted) {
        stateText = "{}";
       }
      }
      initialState = JSON.parse(stateText);
     } catch (e) {
      console.error("Failed to load state:", e);
      initialState = {};
     }
    }
    if (decryptionCancelled) {
     NODE_DATA = {};
     EDGE_DATA = {
      list: []
     };
     EDGE_LEGEND = {};
     savedPositions = {};
     savedSizes = {};
     savedStyles = {};
    } else {
     NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
     EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
      list: [],
     };
     EDGE_LEGEND = initialState.edgeLegend || {};
     savedPositions = initialState.nodePositions || {};
     savedSizes = initialState.nodeSizes || {};
     savedStyles = initialState.nodeStyles || {};
     if (initialState.iconCache) {
      IconLibrary.iconCache = initialState.iconCache;
     }
    }
    if (initialState.page) {
     PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
    }
    if (initialState.canvas) {
     canvasState.zoom = initialState.canvas.zoom || 1;
     canvasState.panX = initialState.canvas.panX || 0;
     canvasState.panY = initialState.canvas.panY || 0;
    }
    wieldThePower();
    forgeTheTopology();
    updateViewBox();
    const initialNodes = Object.keys(NODE_DATA);
    if (initialNodes.length > 0) {
     claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
    } else {
     document.getElementById("node-panel").style.display = "none";
     document.getElementById("topology-toolbar").style.display = "none";
    }
   })();

   function saveEdgeData() {}

   function saveEdgeLegend() {}

   function getBreakpointKey() {
    const w = window.innerWidth;
    if (w <= 380) return "fold";
    if (w <= 768) return "mobile";
    if (w <= 1024) return "tablet";
    return "desktop";
   }

   function resolveStylesEntry(styleEntry) {
    if (!styleEntry) return {};
    if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
     return styleEntry;
    }
    const bp = getBreakpointKey();
    const base = styleEntry.all || {};
    const bpStyles = styleEntry[bp] || {};
    return Object.assign({}, base, bpStyles);
   }

   function resolveStylesForNode(id) {
    const styleEntry = savedStyles[id];
    if (!styleEntry) return {};
    return resolveStylesEntry(styleEntry);
   }

   function ensureStyleEntry(id) {
    if (!savedStyles[id]) savedStyles[id] = {};
    const entry = savedStyles[id];
    const flatProps = ["circleColor", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
    const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
    if (isFlat) {
     const all = entry.all || {};
     flatProps.forEach((p) => {
      if (entry[p] !== undefined) {
       all[p] = entry[p];
       delete entry[p];
      }
     });
     entry.all = all;
    }
    return entry;
   }

   function getDefaultSize() {
    if (window.innerWidth <= 380) return 120;
    if (window.innerWidth <= 768) return 140;
    if (window.innerWidth <= 1024) return 70;
    return 55;
   }

   function createShapeElement(shape, size) {
    const ns = "http://www.w3.org/2000/svg";
    if (shape === "circle") {
     const c = document.createElementNS(ns, "circle");
     c.setAttribute("r", size);
     return c;
    }
    if (shape === "square") {
     const r = document.createElementNS(ns, "rect");
     const s = size * 2;
     r.setAttribute("x", -size);
     r.setAttribute("y", -size);
     r.setAttribute("width", s);
     r.setAttribute("height", s);
     r.setAttribute("rx", 4);
     return r;
    }
    if (shape === "rectangle") {
     const r = document.createElementNS(ns, "rect");
     r.setAttribute("x", -size * 1.4);
     r.setAttribute("y", -size * 0.8);
     r.setAttribute("width", size * 2.8);
     r.setAttribute("height", size * 1.6);
     r.setAttribute("rx", 6);
     return r;
    }
    if (shape === "triangle") {
     const p = document.createElementNS(ns, "polygon");
     const h = size * 1.8;
     const w = size * 2;
     p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
     return p;
    }
    if (shape === "hexagon") {
     const p = document.createElementNS(ns, "polygon");
     const s = size;
     const pts = [
      [0, -s],
      [s * 0.86, -s * 0.5],
      [s * 0.86, s * 0.5],
      [0, s],
      [-s * 0.86, s * 0.5],
      [-s * 0.86, -s * 0.5],
     ].map((pt) => pt.join(",")).join(" ");
     p.setAttribute("points", pts);
     return p;
    }
    if (shape === "stop-sign") {
     const p = document.createElementNS(ns, "polygon");
     const r = size;
     const ptsArr = [];
     for (let i = 0; i < 8; i++) {
      const a = (Math.PI / 4) * i + Math.PI / 8;
      ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
     }
     const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
     p.setAttribute("points", pts);
     return p;
    }
    if (shape === "star") {
     const p = document.createElementNS(ns, "polygon");
     const outer = size;
     const inner = size * 0.45;
     let pts = "";
     for (let i = 0; i < 10; i++) {
      const a = (Math.PI / 5) * i - Math.PI / 2;
      const r = i % 2 === 0 ? outer : inner;
      pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
     }
     p.setAttribute("points", pts.trim());
     return p;
    }
    if (shape === "diamond") {
     const p = document.createElementNS(ns, "polygon");
     const s = size;
     p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
     return p;
    }
    if (shape === "server") {
     const g = document.createElementNS(ns, "g");
     const body = document.createElementNS(ns, "rect");
     body.setAttribute("x", -size * 1.2);
     body.setAttribute("y", -size * 0.6);
     body.setAttribute("width", size * 2.4);
     body.setAttribute("height", size * 1.2);
     body.setAttribute("rx", 4);
     g.appendChild(body);
     for (let i = 0; i < 3; i++) {
      const line = document.createElementNS(ns, "line");
      line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
      line.setAttribute("y1", -size * 0.3);
      line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
      line.setAttribute("y2", size * 0.3);
      line.style.stroke = "currentColor";
      line.style.strokeWidth = "2";
      line.style.opacity = "0.5";
      g.appendChild(line);
     }
     const led = document.createElementNS(ns, "circle");
     led.setAttribute("cx", size * 0.9);
     led.setAttribute("cy", 0);
     led.setAttribute("r", size * 0.1);
     led.style.fill = "#4ade80";
     g.appendChild(led);
     return g;
    }
    if (shape === "pc" || shape === "desktop") {
     const g = document.createElementNS(ns, "g");
     const monitor = document.createElementNS(ns, "rect");
     monitor.setAttribute("x", -size * 0.9);
     monitor.setAttribute("y", -size * 0.8);
     monitor.setAttribute("width", size * 1.8);
     monitor.setAttribute("height", size * 1.2);
     monitor.setAttribute("rx", 4);
     g.appendChild(monitor);
     const screen = document.createElementNS(ns, "rect");
     screen.setAttribute("x", -size * 0.75);
     screen.setAttribute("y", -size * 0.65);
     screen.setAttribute("width", size * 1.5);
     screen.setAttribute("height", size * 0.9);
     screen.setAttribute("rx", 2);
     screen.style.fill = "#1e293b";
     g.appendChild(screen);
     const neck = document.createElementNS(ns, "rect");
     neck.setAttribute("x", -size * 0.15);
     neck.setAttribute("y", size * 0.4);
     neck.setAttribute("width", size * 0.3);
     neck.setAttribute("height", size * 0.3);
     g.appendChild(neck);
     const base = document.createElementNS(ns, "rect");
     base.setAttribute("x", -size * 0.5);
     base.setAttribute("y", size * 0.7);
     base.setAttribute("width", size * 1);
     base.setAttribute("height", size * 0.15);
     base.setAttribute("rx", 2);
     g.appendChild(base);
     return g;
    }
    if (shape === "laptop") {
     const g = document.createElementNS(ns, "g");
     const screen = document.createElementNS(ns, "rect");
     screen.setAttribute("x", -size * 0.8);
     screen.setAttribute("y", -size * 0.9);
     screen.setAttribute("width", size * 1.6);
     screen.setAttribute("height", size * 1.1);
     screen.setAttribute("rx", 4);
     g.appendChild(screen);
     const base = document.createElementNS(ns, "rect");
     base.setAttribute("x", -size * 0.9);
     base.setAttribute("y", size * 0.25);
     base.setAttribute("width", size * 1.8);
     base.setAttribute("height", size * 0.6);
     base.setAttribute("rx", 4);
     g.appendChild(base);
     const pad = document.createElementNS(ns, "rect");
     pad.setAttribute("x", -size * 0.25);
     pad.setAttribute("y", size * 0.45);
     pad.setAttribute("width", size * 0.5);
     pad.setAttribute("height", size * 0.25);
     pad.setAttribute("rx", 2);
     pad.style.fill = "#1e293b";
     g.appendChild(pad);
     return g;
    }
    if (shape === "phone" || shape === "mobile") {
     const g = document.createElementNS(ns, "g");
     const body = document.createElementNS(ns, "rect");
     body.setAttribute("x", -size * 0.45);
     body.setAttribute("y", -size);
     body.setAttribute("width", size * 0.9);
     body.setAttribute("height", size * 2);
     body.setAttribute("rx", 8);
     g.appendChild(body);
     const screen = document.createElementNS(ns, "rect");
     screen.setAttribute("x", -size * 0.38);
     screen.setAttribute("y", -size * 0.85);
     screen.setAttribute("width", size * 0.76);
     screen.setAttribute("height", size * 1.6);
     screen.setAttribute("rx", 4);
     screen.style.fill = "#1e293b";
     g.appendChild(screen);
     const btn = document.createElementNS(ns, "rect");
     btn.setAttribute("x", -size * 0.15);
     btn.setAttribute("y", size * 0.82);
     btn.setAttribute("width", size * 0.3);
     btn.setAttribute("height", size * 0.06);
     btn.setAttribute("rx", 2);
     btn.style.fill = "#475569";
     g.appendChild(btn);
     return g;
    }
    if (shape === "router") {
     const g = document.createElementNS(ns, "g");
     const body = document.createElementNS(ns, "rect");
     body.setAttribute("x", -size * 1.1);
     body.setAttribute("y", -size * 0.3);
     body.setAttribute("width", size * 2.2);
     body.setAttribute("height", size * 0.8);
     body.setAttribute("rx", 6);
     g.appendChild(body);
     for (let i = -1; i <= 1; i++) {
      const ant = document.createElementNS(ns, "rect");
      ant.setAttribute("x", i * size * 0.6 - size * 0.05);
      ant.setAttribute("y", -size * 0.9);
      ant.setAttribute("width", size * 0.1);
      ant.setAttribute("height", size * 0.6);
      ant.setAttribute("rx", 2);
      g.appendChild(ant);
      const tip = document.createElementNS(ns, "circle");
      tip.setAttribute("cx", i * size * 0.6);
      tip.setAttribute("cy", -size * 0.95);
      tip.setAttribute("r", size * 0.08);
      g.appendChild(tip);
     }
     for (let i = 0; i < 4; i++) {
      const led = document.createElementNS(ns, "circle");
      led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
      led.setAttribute("cy", size * 0.1);
      led.setAttribute("r", size * 0.06);
      led.style.fill = i < 2 ? "#4ade80" : "#facc15";
      g.appendChild(led);
     }
     return g;
    }
    if (shape === "switch") {
     const g = document.createElementNS(ns, "g");
     const body = document.createElementNS(ns, "rect");
     body.setAttribute("x", -size * 1.4);
     body.setAttribute("y", -size * 0.4);
     body.setAttribute("width", size * 2.8);
     body.setAttribute("height", size * 0.8);
     body.setAttribute("rx", 4);
     g.appendChild(body);
     for (let i = 0; i < 8; i++) {
      const port = document.createElementNS(ns, "rect");
      port.setAttribute("x", -size * 1.2 + i * size * 0.32);
      port.setAttribute("y", -size * 0.15);
      port.setAttribute("width", size * 0.22);
      port.setAttribute("height", size * 0.3);
      port.setAttribute("rx", 1);
      port.style.fill = "#1e293b";
      g.appendChild(port);
     }
     return g;
    }
    if (shape === "firewall") {
     const g = document.createElementNS(ns, "g");
     const wall = document.createElementNS(ns, "rect");
     wall.setAttribute("x", -size);
     wall.setAttribute("y", -size * 0.8);
     wall.setAttribute("width", size * 2);
     wall.setAttribute("height", size * 1.6);
     wall.setAttribute("rx", 4);
     g.appendChild(wall);
     for (let row = 0; row < 3; row++) {
      const line = document.createElementNS(ns, "line");
      line.setAttribute("x1", -size * 0.85);
      line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
      line.setAttribute("x2", size * 0.85);
      line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
      line.style.stroke = "#475569";
      line.style.strokeWidth = "2";
      g.appendChild(line);
     }
     for (let row = 0; row < 4; row++) {
      const offset = row % 2 === 0 ? 0 : size * 0.35;
      for (let col = 0; col < 3; col++) {
       const line = document.createElementNS(ns, "line");
       const x = -size * 0.5 + col * size * 0.7 + offset;
       if (x > -size * 0.85 && x < size * 0.85) {
        line.setAttribute("x1", x);
        line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
        line.setAttribute("x2", x);
        line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
        line.style.stroke = "#475569";
        line.style.strokeWidth = "2";
        g.appendChild(line);
       }
      }
     }
     return g;
    }
    if (shape === "cloud") {
     const p = document.createElementNS(ns, "path");
     const s = size;
     p.setAttribute("d", `
          M ${-s * 0.8} ${s * 0.2}
          Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
          Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
          Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
          Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
          Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
          Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
          Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
          L ${-s * 0.5} ${s * 0.5}
          Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
          Z
         `, );
     return p;
    }
    if (shape === "database") {
     const g = document.createElementNS(ns, "g");
     const body = document.createElementNS(ns, "rect");
     body.setAttribute("x", -size * 0.7);
     body.setAttribute("y", -size * 0.6);
     body.setAttribute("width", size * 1.4);
     body.setAttribute("height", size * 1.4);
     g.appendChild(body);
     const top = document.createElementNS(ns, "ellipse");
     top.setAttribute("cx", 0);
     top.setAttribute("cy", -size * 0.6);
     top.setAttribute("rx", size * 0.7);
     top.setAttribute("ry", size * 0.25);
     g.appendChild(top);
     const bottom = document.createElementNS(ns, "ellipse");
     bottom.setAttribute("cx", 0);
     bottom.setAttribute("cy", size * 0.8);
     bottom.setAttribute("rx", size * 0.7);
     bottom.setAttribute("ry", size * 0.25);
     g.appendChild(bottom);
     const mid1 = document.createElementNS(ns, "ellipse");
     mid1.setAttribute("cx", 0);
     mid1.setAttribute("cy", -size * 0.15);
     mid1.setAttribute("rx", size * 0.7);
     mid1.setAttribute("ry", size * 0.2);
     mid1.style.fill = "none";
     mid1.style.stroke = "#475569";
     mid1.style.strokeWidth = "2";
     g.appendChild(mid1);
     const mid2 = document.createElementNS(ns, "ellipse");
     mid2.setAttribute("cx", 0);
     mid2.setAttribute("cy", size * 0.35);
     mid2.setAttribute("rx", size * 0.7);
     mid2.setAttribute("ry", size * 0.2);
     mid2.style.fill = "none";
     mid2.style.stroke = "#475569";
     mid2.style.strokeWidth = "2";
     g.appendChild(mid2);
     return g;
    }
    if (shape === "printer") {
     const g = document.createElementNS(ns, "g");
     const body = document.createElementNS(ns, "rect");
     body.setAttribute("x", -size);
     body.setAttribute("y", -size * 0.4);
     body.setAttribute("width", size * 2);
     body.setAttribute("height", size * 0.9);
     body.setAttribute("rx", 4);
     g.appendChild(body);
     const trayTop = document.createElementNS(ns, "rect");
     trayTop.setAttribute("x", -size * 0.7);
     trayTop.setAttribute("y", -size * 0.8);
     trayTop.setAttribute("width", size * 1.4);
     trayTop.setAttribute("height", size * 0.4);
     trayTop.setAttribute("rx", 2);
     trayTop.style.fill = "#1e293b";
     g.appendChild(trayTop);
     const trayOut = document.createElementNS(ns, "rect");
     trayOut.setAttribute("x", -size * 0.6);
     trayOut.setAttribute("y", size * 0.5);
     trayOut.setAttribute("width", size * 1.2);
     trayOut.setAttribute("height", size * 0.35);
     trayOut.setAttribute("rx", 2);
     g.appendChild(trayOut);
     const paper = document.createElementNS(ns, "rect");
     paper.setAttribute("x", -size * 0.5);
     paper.setAttribute("y", size * 0.3);
     paper.setAttribute("width", size * 1);
     paper.setAttribute("height", size * 0.5);
     paper.style.fill = "#e2e8f0";
     g.appendChild(paper);
     return g;
    }
    const c = document.createElementNS(ns, "circle");
    c.setAttribute("r", size);
    return c;
   }

   function createNodeShape(id, size) {
    const styles = resolveStylesForNode(id);
	
    if (styles.icon && styles.icon.library && styles.icon.name) {
     const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
     g.classList.add("node-circle");
     
     IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
      if (svgText) {
       const parser = new DOMParser();
       const doc = parser.parseFromString(svgText, 'image/svg+xml');
       const svgEl = doc.querySelector('svg');
       if (svgEl) {
        svgEl.setAttribute('width', size * 1.2);
        svgEl.setAttribute('height', size * 1.2);
        svgEl.setAttribute('x', -size * 0.6);
        svgEl.setAttribute('y', -size * 0.6);
        if (styles.circleColor) {
         svgEl.style.fill = styles.circleColor;
        }
        g.innerHTML = svgEl.outerHTML;
       }
      }
     });
     
     return g;
    }

    const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
    const shapeEl = createShapeElement(shapeType, size);
    shapeEl.classList.add("node-circle");
    if (styles.circleColor) {
     shapeEl.style.stroke = styles.circleColor;
    }
    return shapeEl;
   }

   function forgeTheLegend() {
    const container = document.getElementById("edge-legend");
    if (!container) return;
    container.innerHTML = "";
    const title = document.createElement("div");
    title.className = "legend-title";
    title.textContent = "Line Legend";
    container.appendChild(title);
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.className = "legend-close-btn";
    closeBtn.textContent = "‚úï";
    closeBtn.addEventListener("click", (e) => {
     e.stopPropagation();
     legendCollapsed = true;
     updateLegendVisibility();
    });
    container.appendChild(closeBtn);
    const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
    if (colors.length === 0) {
     updateLegendVisibility();
     return;
    }
    colors.forEach((color) => {
     if (!EDGE_LEGEND[color]) {
      EDGE_LEGEND[color] = "you can edit me too";
     }
     const item = document.createElement("div");
     item.className = "legend-item";
     item.addEventListener("mousedown", (e) => e.stopPropagation());
     item.addEventListener("click", (e) => e.stopPropagation());
     const swatch = document.createElement("span");
     swatch.className = "legend-swatch";
     swatch.style.backgroundColor = color;
     const label = document.createElement("span");
     label.className = "legend-label";
     label.textContent = EDGE_LEGEND[color];
     label.contentEditable = true;
     label.addEventListener("mousedown", (e) => e.stopPropagation());
     label.addEventListener("click", (e) => e.stopPropagation());
     label.addEventListener("touchstart", (e) => e.stopPropagation());
     label.addEventListener("focus", () => {
      label.classList.add("editing");
     });
     label.addEventListener("blur", () => {
      label.classList.remove("editing");
      const text = label.textContent.trim() || "you can edit me too";
      EDGE_LEGEND[color] = text;
      saveEdgeLegend();
     });
     label.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
       e.preventDefault();
       label.blur();
      }
     });
     item.append(swatch, label);
     container.appendChild(item);
    });
    updateLegendVisibility();
   }

   function forgeTheTopology() {
    if (!NODE_DATA || !EDGE_DATA) {
     console.warn("forgeTheTopology called before data initialized");
     return;
    }
    const svg = document.getElementById("map");
    svg.innerHTML = "";
    const ns = "http://www.w3.org/2000/svg";
    const defs = document.createElementNS(ns, "defs");
    const markerForward = document.createElementNS(ns, "marker");
    markerForward.id = "arrow-forward";
    markerForward.setAttribute("markerWidth", "10");
    markerForward.setAttribute("markerHeight", "10");
    markerForward.setAttribute("refX", "9");
    markerForward.setAttribute("refY", "3");
    markerForward.setAttribute("orient", "auto");
    markerForward.setAttribute("markerUnits", "strokeWidth");
    const pathForward = document.createElementNS(ns, "path");
    pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
    pathForward.setAttribute("fill", "context-stroke");
    markerForward.appendChild(pathForward);
    defs.appendChild(markerForward);
    const markerBackward = document.createElementNS(ns, "marker");
    markerBackward.id = "arrow-backward";
    markerBackward.setAttribute("markerWidth", "10");
    markerBackward.setAttribute("markerHeight", "10");
    markerBackward.setAttribute("refX", "0");
    markerBackward.setAttribute("refY", "3");
    markerBackward.setAttribute("orient", "auto");
    markerBackward.setAttribute("markerUnits", "strokeWidth");
    const pathBackward = document.createElementNS(ns, "path");
    pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
    pathBackward.setAttribute("fill", "context-stroke");
    markerBackward.appendChild(pathBackward);
    defs.appendChild(markerBackward);
    svg.appendChild(defs);
    const boundary = document.createElementNS(ns, "rect");
    boundary.setAttribute("x", CANVAS_PADDING);
    boundary.setAttribute("y", CANVAS_PADDING);
    boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
    boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
    boundary.setAttribute("fill", "none");
    boundary.setAttribute("stroke", "rgba(71, 85, 105, 0.3)");
    boundary.setAttribute("stroke-width", "2");
    boundary.setAttribute("stroke-dasharray", "10 5");
    boundary.setAttribute("rx", "8");
    svg.appendChild(boundary);
    const centerX = CANVAS_WIDTH / 2;
    const centerY = CANVAS_HEIGHT / 2;
    let positions = {};
    Object.keys(NODE_DATA).forEach((id) => {
     positions[id] = savedPositions[id] || {
      x: centerX,
      y: centerY
     };
    });
    if (Object.keys(savedPositions).length === 0) {
     const nodeIds = Object.keys(NODE_DATA);
     const baseY = centerY - 300;
     if (nodeIds.length > 0) {
      positions[nodeIds[0]] = {
       x: centerX,
       y: baseY
      };
      const remaining = nodeIds.slice(1);
      const radius = 350;
      const startAngle = Math.PI * 0.3;
      const endAngle = Math.PI * 0.7;
      remaining.forEach((id, i) => {
       const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
       positions[id] = {
        x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
        y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
       };
      });
     }
    }
    Object.keys(positions).forEach((id) => {
     let pos = savedPositions[id] || positions[id];
     const nodeSize = savedSizes[id] || 55;
     pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
     pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
     positions[id] = {
      x: pos.x,
      y: pos.y
     };
     savedPositions[id] = {
      x: pos.x,
      y: pos.y
     };
    });
    const edgePairCount = {};
    const edgePairIndex = {};
    EDGE_DATA.list.forEach((edge) => {
     if (edge.type === "custom") return;
     const key = [edge.from, edge.to].sort().join("||");
     edgePairCount[key] = (edgePairCount[key] || 0) + 1;
    });
    EDGE_DATA.list.forEach((edge) => {
     if (edge.type === "custom") return;
     const key = [edge.from, edge.to].sort().join("||");
     if (!edgePairIndex[key]) edgePairIndex[key] = 0;
     edge._pairIndex = edgePairIndex[key];
     edge._pairTotal = edgePairCount[key];
     edgePairIndex[key]++;
    });
    EDGE_DATA.list.forEach((edge) => {
     if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
      const poly = document.createElementNS(ns, "polyline");
      poly.classList.add("edge");
      poly.dataset.edgeId = edge.id;
      poly.style.stroke = edge.color || "#475569";
      poly.style.strokeWidth = edge.width || 4;
      poly.setAttribute("fill", "none");
      const lineStyle = edge.lineStyle || "solid";
      if (lineStyle === "dashed") {
       poly.style.strokeDasharray = "10,5";
      } else if (lineStyle === "dotted") {
       poly.style.strokeDasharray = "2,4";
      } else {
       poly.style.strokeDasharray = "none";
      }
      const direction = edge.direction || "none";
      if (direction === "forward") {
       poly.setAttribute("marker-end", "url(#arrow-forward)");
      } else if (direction === "backward") {
       poly.setAttribute("marker-start", "url(#arrow-backward)");
      } else if (direction === "both") {
       poly.setAttribute("marker-start", "url(#arrow-backward)");
       poly.setAttribute("marker-end", "url(#arrow-forward)");
      }
      const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
      poly.setAttribute("points", ptsStr);
      poly.addEventListener("click", (e) => {
       e.stopPropagation();
       selectTheConnection(edge.id);
      });
      svg.appendChild(poly);
      return;
     }
     const p1 = positions[edge.from];
     const p2 = positions[edge.to];
     if (!p1 || !p2) return;
     const pairTotal = edge._pairTotal || 1;
     const pairIndex = edge._pairIndex || 0;
     const midX = (p1.x + p2.x) / 2;
     const midY = (p1.y + p2.y) / 2;
     const dx = p2.x - p1.x;
     const dy = p2.y - p1.y;
     const len = Math.sqrt(dx * dx + dy * dy) || 1;
     const perpX = -dy / len;
     const perpY = dx / len;
     let offsetAmount = 0;
     if (pairTotal > 1) {
      offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
     }
     const ctrlX = midX + perpX * offsetAmount;
     const ctrlY = midY + perpY * offsetAmount;
     const path = document.createElementNS(ns, "path");
     path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
     path.setAttribute("fill", "none");
     path.classList.add("edge");
     if (edge.type === "backup") path.classList.add("backup");
     path.dataset.edgeId = edge.id;
     path.dataset.from = edge.from;
     path.dataset.to = edge.to;
     path.style.stroke = edge.color;
     path.style.strokeWidth = edge.width;
     path.addEventListener("click", (e) => {
      e.stopPropagation();
      selectTheConnection(edge.id);
     });
     svg.appendChild(path);
    });
    Object.entries(positions).forEach(([id, pos]) => {
     const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
     g.classList.add("node-group");
     g.dataset.nodeId = id;
     g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
     let r = savedSizes[id] || 55;
     if (!savedSizes[id]) {
      if (window.innerWidth <= 380) r = 120;
      else if (window.innerWidth <= 768) r = 140;
      else if (window.innerWidth <= 1024) r = 70;
     }
     const styles = resolveStylesForNode(id);
     const shapeEl = createNodeShape(id, r);
     const titleOffsetX = styles.titleOffsetX || 0;
     const titleOffsetY = styles.titleOffsetY || 0;
     const subOffsetX = styles.subOffsetX || 0;
     const subOffsetY = styles.subOffsetY || 0;
     const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
     label.classList.add("node-label");
     label.setAttribute("x", titleOffsetX);
     label.setAttribute("y", -r * 0.28 + titleOffsetY);
     const labelFontSize = styles.titleSize || r * 0.33;
     label.style.fontSize = labelFontSize + "px";
     label.textContent = NODE_DATA[id].name;
     if (styles.titleColor) label.style.fill = styles.titleColor;
     if (styles.titleFont) label.style.fontFamily = styles.titleFont;
     label.style.cursor = "pointer";
     label.addEventListener("click", (e) => {
      e.stopPropagation();
      editNodeName(id);
     });
     const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
     sub.classList.add("node-sub");
     sub.setAttribute("x", subOffsetX);
     sub.setAttribute("y", r * 0.4 + subOffsetY);
     const subFontSize = styles.subSize || r * 0.24;
     sub.style.fontSize = subFontSize + "px";
     sub.textContent = NODE_DATA[id].ip;
     if (styles.subColor) sub.style.fill = styles.subColor;
     if (styles.subFont) sub.style.fontFamily = styles.subFont;
     sub.style.cursor = "pointer";
     sub.addEventListener("click", (e) => {
      e.stopPropagation();
      editNodeIp(id);
     });
     g.append(shapeEl, label, sub);
     let isDragging = false;
     let startX, startY;
     g.addEventListener("mousedown", (e) => {
      e.preventDefault();
      isDragging = true;
      const svgEl = document.getElementById("map");
      const pt = svgEl.createSVGPoint();
      pt.x = e.clientX;
      pt.y = e.clientY;
      const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
      startX = svgP.x - pos.x;
      startY = svgP.y - pos.y;
      g.style.cursor = "grabbing";
      e.stopPropagation();
     });
     const handleMouseMove = (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const svgEl = document.getElementById("map");
      const pt = svgEl.createSVGPoint();
      pt.x = e.clientX;
      pt.y = e.clientY;
      const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
      let newX = svgP.x - startX;
      let newY = svgP.y - startY;
      const nodeSize = savedSizes[id] || 55;
      newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
      newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
      pos.x = newX;
      pos.y = newY;
      g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
      positions[id] = {
       x: pos.x,
       y: pos.y
      };
      savedPositions[id] = {
       x: pos.x,
       y: pos.y
      };
      updateMinimap();
      document.querySelectorAll(".edge").forEach((edgeEl) => {
       const fromId = edgeEl.dataset.from;
       const toId = edgeEl.dataset.to;
       if (fromId === id || toId === id) {
        const p1 = savedPositions[fromId] || positions[fromId] || {
         x: 600,
         y: 350
        };
        const p2 = savedPositions[toId] || positions[toId] || {
         x: 600,
         y: 350
        };
        if (edgeEl.tagName === "line") {
         edgeEl.setAttribute("x1", p1.x);
         edgeEl.setAttribute("y1", p1.y);
         edgeEl.setAttribute("x2", p2.x);
         edgeEl.setAttribute("y2", p2.y);
        } else if (edgeEl.tagName === "path") {
         const edgeId = edgeEl.dataset.edgeId;
         const edge = EDGE_DATA.list.find(
          (e) => e.id === edgeId, );
         if (edge) {
          const pairTotal = edge._pairTotal || 1;
          const pairIndex = edge._pairIndex || 0;
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const perpX = -dy / len;
          const perpY = dx / len;
          let offsetAmount = 0;
          if (pairTotal > 1) {
           offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
          }
          const ctrlX = midX + perpX * offsetAmount;
          const ctrlY = midY + perpY * offsetAmount;
          edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         }
        }
       }
      });
     };
     const handleMouseUp = () => {
      if (isDragging) {
       isDragging = false;
       g.style.cursor = "grab";
       savedPositions[id] = {
        x: pos.x,
        y: pos.y
       };
      }
     };
     document.addEventListener("mousemove", handleMouseMove);
     document.addEventListener("mouseup", handleMouseUp);
     g.addEventListener("touchstart",
      (e) => {
       e.preventDefault();
       isDragging = true;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       const touch = e.touches[0];
       pt.x = touch.clientX;
       pt.y = touch.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
       startX = svgP.x - pos.x;
       startY = svgP.y - pos.y;
       e.stopPropagation();
      }, {
       passive: false
      }, );
     const handleTouchMove = (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const svgEl = document.getElementById("map");
      const pt = svgEl.createSVGPoint();
      const touch = e.touches[0];
      pt.x = touch.clientX;
      pt.y = touch.clientY;
      const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
      let newX = svgP.x - startX;
      let newY = svgP.y - startY;
      const nodeSize = savedSizes[id] || 55;
      newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
      newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
      pos.x = newX;
      pos.y = newY;
      g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
      positions[id] = {
       x: pos.x,
       y: pos.y
      };
      savedPositions[id] = {
       x: pos.x,
       y: pos.y
      };
      updateMinimap();
      document.querySelectorAll(".edge").forEach((edgeEl) => {
       const fromId = edgeEl.dataset.from;
       const toId = edgeEl.dataset.to;
       if (fromId === id || toId === id) {
        const p1 = savedPositions[fromId] || positions[fromId] || {
         x: 600,
         y: 350
        };
        const p2 = savedPositions[toId] || positions[toId] || {
         x: 600,
         y: 350
        };
        if (edgeEl.tagName === "line") {
         edgeEl.setAttribute("x1", p1.x);
         edgeEl.setAttribute("y1", p1.y);
         edgeEl.setAttribute("x2", p2.x);
         edgeEl.setAttribute("y2", p2.y);
        } else if (edgeEl.tagName === "path") {
         const edgeId = edgeEl.dataset.edgeId;
         const edge = EDGE_DATA.list.find(
          (e) => e.id === edgeId, );
         if (edge) {
          const pairTotal = edge._pairTotal || 1;
          const pairIndex = edge._pairIndex || 0;
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const perpX = -dy / len;
          const perpY = dx / len;
          let offsetAmount = 0;
          if (pairTotal > 1) {
           offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
          }
          const ctrlX = midX + perpX * offsetAmount;
          const ctrlY = midY + perpY * offsetAmount;
          edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         }
        }
       }
      });
     };
     const handleTouchEnd = () => {
      if (isDragging) {
       isDragging = false;
       savedPositions[id] = {
        x: pos.x,
        y: pos.y
       };
      }
     };
     document.addEventListener("touchmove", handleTouchMove, {
      passive: false,
     });
     document.addEventListener("touchend", handleTouchEnd);
     g.style.cursor = "grab";
     g.addEventListener("click", (e) => {
      if (!isDragging) {
       claimTheImmortal(id);
      }
     });
     svg.appendChild(g);
    });
    forgeTheLegend();
    updateMinimap();
   }

   function showEditModal(title, currentValue, onSave) {
    const modal = document.getElementById("edit-modal");
    const input = document.getElementById("modal-input");
    const titleEl = document.getElementById("modal-title");
    const saveBtn = document.getElementById("modal-save");
    const cancelBtn = document.getElementById("modal-cancel");
    titleEl.textContent = title;
    input.value = currentValue;
    modal.classList.add("active");
    input.focus();
    input.select();
    const handleSave = () => {
     if (input.value.trim()) {
      onSave(input.value.trim());
     }
     modal.classList.remove("active");
     saveBtn.removeEventListener("click", handleSave);
     cancelBtn.removeEventListener("click", handleCancel);
     input.removeEventListener("keypress", handleEnter);
    };
    const handleCancel = () => {
     modal.classList.remove("active");
     saveBtn.removeEventListener("click", handleSave);
     cancelBtn.removeEventListener("click", handleCancel);
     input.removeEventListener("keypress", handleEnter);
    };
    const handleEnter = (e) => {
     if (e.key === "Enter") handleSave();
    };
    saveBtn.addEventListener("click", handleSave);
    cancelBtn.addEventListener("click", handleCancel);
    input.addEventListener("keypress", handleEnter);
    modal.addEventListener("click", function bgHandler(e) {
     if (e.target === modal) {
      handleCancel();
      modal.removeEventListener("click", bgHandler);
     }
    });
   }

   function challengeTheImmortal(message, onConfirm) {
    const modal = document.getElementById("confirm-modal");
    const messageEl = document.getElementById("confirm-message");
    const deleteBtn = document.getElementById("confirm-delete");
    const cancelBtn = document.getElementById("confirm-cancel");
    messageEl.textContent = message;
    modal.classList.add("active");
    const handleConfirm = () => {
     onConfirm();
     modal.classList.remove("active");
     deleteBtn.removeEventListener("click", handleConfirm);
     cancelBtn.removeEventListener("click", handleCancel);
    };
    const handleCancel = () => {
     modal.classList.remove("active");
     deleteBtn.removeEventListener("click", handleConfirm);
     cancelBtn.removeEventListener("click", handleCancel);
    };
    deleteBtn.addEventListener("click", handleConfirm);
    cancelBtn.addEventListener("click", handleCancel);
    modal.addEventListener("click", function bgHandler(e) {
     if (e.target === modal) {
      handleCancel();
      modal.removeEventListener("click", bgHandler);
     }
    });
   }
   const pageTitleEl = document.getElementById("page-title");
   if (pageTitleEl) {
    pageTitleEl.addEventListener("click", () => {
     showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
      (newTitle) => {
       PAGE_STATE.title = newTitle;
       wieldThePower();
      }, );
    });
   }

   function editNodeName(id) {
    showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
     NODE_DATA[id].name = newName;
     const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
     if (nodeGroup) {
      const label = nodeGroup.querySelector(".node-label");
      if (label) label.textContent = newName;
     }
     if (currentNodeId === id) {
      document.getElementById("node-name").textContent = newName;
     }
    });
   }

   function editNodeIp(id) {
    showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
     NODE_DATA[id].ip = newIp;
     const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
     if (nodeGroup) {
      const sub = nodeGroup.querySelector(".node-sub");
      if (sub) sub.textContent = newIp;
     }
     if (currentNodeId === id) {
      document.getElementById("node-ip").textContent = newIp;
     }
    });
   }

   function claimTheImmortal(id) {
    currentNodeId = id;
    currentEdgeId = null;
    const data = NODE_DATA[id];
    document.querySelectorAll(".node-group").forEach((n) => {
     n.classList.toggle("active", n.dataset.nodeId === id);
    });
    document.querySelectorAll(".edge").forEach((e) => {
     const active = e.dataset.from === id || e.dataset.to === id;
     e.classList.toggle("active", active);
    });
    document.getElementById("node-panel").style.display = "block";
    document.getElementById("edge-panel").style.display = "none";
    const toolbar = document.getElementById("topology-toolbar");
    toolbar.style.display = "flex";
    document.getElementById("node-name").textContent = data.name;
    document.getElementById("node-ip").textContent = data.ip;
    document.getElementById("node-role").textContent = data.role;
    document.getElementById("node-name").onclick = () => editNodeName(id);
    document.getElementById("node-ip").onclick = () => editNodeIp(id);
    const currentSize = savedSizes[id] || getDefaultSize();
    document.getElementById("size-slider").value = currentSize;
    document.getElementById("size-value").textContent = currentSize;
    const styleEntry = savedStyles[id] || {};
    const resolvedStyles = resolveStylesEntry(styleEntry);
    const scopeKey = currentStyleScope || "all";
    const flatProps = ["circleColor", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
    const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
    const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
    const circleColorInput = document.getElementById("circle-color");
    const titleColorInput = document.getElementById("title-color");
    const titleFontSelect = document.getElementById("title-font");
    const titleSizeInput = document.getElementById("title-size");
    const subColorInput = document.getElementById("sub-color");
    const subFontSelect = document.getElementById("sub-font");
    const subSizeInput = document.getElementById("sub-size");
    const shapeSelect = document.getElementById("shape-select");
    const scopeSelect = document.getElementById("style-scope");
    circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || "#1e293b";
    titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || "#e2e8f0";
    titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
    titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
    subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || "#94a3b8";
    subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
    subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
    shapeSelect.value = data.shape || "circle";
    scopeSelect.value = currentStyleScope || "all";
    document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
    document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
    document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
    document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
    const tagEl = document.getElementById("node-tags");
    tagEl.innerHTML = "";
    data.tags.forEach((tag, i) => {
     const b = document.createElement("span");
     b.className = "badge";
    
     const isIconTag = typeof tag === 'object' && tag.type === 'icon';
     
     if (!isIconTag && tag.toLowerCase().includes("wg")) b.classList.add("wg");
     b.style.cursor = "pointer";
     b.style.position = "relative";
     
     const tagContent = document.createElement("span");
     
     if (isIconTag) {
      b.classList.add("icon-badge");
      IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
       if (svgText) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgText, 'image/svg+xml');
        const svgEl = doc.querySelector('svg');
        if (svgEl) {
         svgEl.setAttribute('width', '16');
         svgEl.setAttribute('height', '16');
         tagContent.innerHTML = '';
         tagContent.appendChild(svgEl);
         const nameSpan = document.createElement('span');
         nameSpan.textContent = tag.name;
         nameSpan.style.marginLeft = '4px';
         tagContent.appendChild(nameSpan);
        }
       }
      });
     } else {
      tagContent.textContent = tag;
      tagContent.addEventListener("click", (e) => {
       e.stopPropagation();
       showEditModal("Edit Tag", tag, (newTag) => {
        if (newTag) {
         data.tags[i] = newTag;
         claimTheImmortal(id);
        }
       });
      });
     }
     
     const deleteTag = document.createElement("span");
     deleteTag.textContent = " ‚úï";
     deleteTag.style.opacity = "0.6";
     deleteTag.style.marginLeft = "4px";
     deleteTag.style.fontSize = "10px";
     deleteTag.addEventListener("click", (e) => {
      e.stopPropagation();
      data.tags.splice(i, 1);
      claimTheImmortal(id);
     });
     b.append(tagContent, deleteTag);
     tagEl.append(b);
    });
    const addTagBtn = document.createElement("span");
    addTagBtn.className = "badge";
    addTagBtn.style.cursor = "pointer";
    addTagBtn.style.opacity = "0.6";
    addTagBtn.style.borderStyle = "dashed";
    addTagBtn.textContent = "+ Add";
    addTagBtn.addEventListener("click", () => {
     showEditModal("Add Tag(s) : comma separated", "",
      (newTagStr) => {
       if (newTagStr) {
        const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
        newTags.forEach((t) => data.tags.push(t));
        claimTheImmortal(id);
       }
      }, );
    });
    tagEl.append(addTagBtn);
    const notesEl = document.getElementById("node-notes");
    notesEl.innerHTML = "";
    data.notes.forEach((note, i) => {
     const li = document.createElement("li");
     const noteText = document.createElement("span");
     noteText.textContent = note;
     noteText.style.flex = "1";
     const deleteBtn = document.createElement("span");
     deleteBtn.className = "delete-note";
     deleteBtn.textContent = "‚úï";
     deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Are you sure you want to delete this note?",
       () => {
        data.notes.splice(i, 1);
        claimTheImmortal(id);
       }, );
     });
     li.append(noteText, deleteBtn);
     noteText.addEventListener("dblclick", () => {
      noteText.classList.add("editing");
      noteText.contentEditable = true;
      noteText.focus();
     });
     noteText.addEventListener("blur", () => {
      noteText.classList.remove("editing");
      noteText.contentEditable = false;
      data.notes[i] = noteText.textContent;
     });
     notesEl.append(li);
    });
    const addLineSelect = document.getElementById("add-line-select");
    addLineSelect.innerHTML = "";
    Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
     if (nodeId !== id) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
     }
    });
   }

   function selectTheConnection(id) {
    currentEdgeId = id;
    document.getElementById("node-panel").style.display = "none";
    document.getElementById("edge-panel").style.display = "block";
    document.getElementById("topology-toolbar").style.display = "none";
    document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
    document.querySelectorAll(".edge").forEach((e) => {
     e.classList.toggle("active", e.dataset.edgeId === id);
    });
    const edge = EDGE_DATA.list.find((e) => e.id === id);
    if (!edge) return;
    const directionSymbols = {
     none: "‚áÑ",
     forward: "‚Üí",
     backward: "‚Üê",
     both: "‚Üî",
    };
    const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
    let titleText = "Custom line";
    if (edge.from || edge.to) {
     const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
     const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
     titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
    }
    document.getElementById("edge-title").textContent = titleText;
    const widthInput = document.getElementById("edge-width");
    const colorInput = document.getElementById("edge-color");
    const directionSelect = document.getElementById("edge-direction");
    const lineStyleSelect = document.getElementById("edge-line-style");
    widthInput.value = edge.width;
    colorInput.value = edge.color;
    directionSelect.value = edge.direction || "none";
    lineStyleSelect.value = edge.lineStyle || "solid";
    const list = document.getElementById("edge-notes");
    list.innerHTML = "";
    edge.notes.forEach((note, i) => {
     const li = document.createElement("li");
     const txt = document.createElement("span");
     txt.textContent = note;
     txt.style.flex = "1";
     const del = document.createElement("span");
     del.className = "delete-note";
     del.textContent = "‚úï";
     del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this line note?", () => {
       edge.notes.splice(i, 1);
       saveEdgeData();
       selectTheConnection(id);
      });
     });
     txt.addEventListener("dblclick", () => {
      txt.classList.add("editing");
      txt.contentEditable = true;
      txt.focus();
     });
     txt.addEventListener("blur", () => {
      txt.classList.remove("editing");
      txt.contentEditable = false;
      edge.notes[i] = txt.textContent;
      saveEdgeData();
     });
     li.append(txt, del);
     list.appendChild(li);
    });
   }
   window.addEventListener("resize", () => {
    forgeTheTopology();
    if (currentEdgeId) {
     selectTheConnection(currentEdgeId);
    } else if (currentNodeId && NODE_DATA[currentNodeId]) {
     claimTheImmortal(currentNodeId);
    } else {
     const availableNodes = Object.keys(NODE_DATA);
     if (availableNodes.length > 0) {
      claimTheImmortal(availableNodes[0]);
     }
    }
   });
   (function initZoomPan() {
    const viewport = document.getElementById("canvas-viewport");
    const svg = document.getElementById("map");
    const hint = document.getElementById("canvas-hint");
    setTimeout(() => {
     hint.classList.add("visible");
     setTimeout(() => hint.classList.remove("visible"), 4000);
    }, 1000);
    viewport.addEventListener("wheel",
     (e) => {
      e.preventDefault();
      const rect = viewport.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) / rect.width;
      const mouseY = (e.clientY - rect.top) / rect.height;
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      zoomTo(canvasState.zoom * delta, mouseX, mouseY);
     }, {
      passive: false
     }, );
    let initialPinchDistance = 0;
    let initialPinchZoom = 1;
    let pinchCenter = {
     x: 0.5,
     y: 0.5
    };
    viewport.addEventListener("touchstart",
     (e) => {
      if (e.touches.length === 2) {
       e.preventDefault();
       const touch1 = e.touches[0];
       const touch2 = e.touches[1];
       initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
       initialPinchZoom = canvasState.zoom;
       const rect = viewport.getBoundingClientRect();
       const centerX = (touch1.clientX + touch2.clientX) / 2;
       const centerY = (touch1.clientY + touch2.clientY) / 2;
       pinchCenter.x = (centerX - rect.left) / rect.width;
       pinchCenter.y = (centerY - rect.top) / rect.height;
      }
     }, {
      passive: false
     }, );
    viewport.addEventListener("touchmove",
     (e) => {
      if (e.touches.length === 2) {
       e.preventDefault();
       const touch1 = e.touches[0];
       const touch2 = e.touches[1];
       const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
       if (initialPinchDistance > 0) {
        const scale = currentDistance / initialPinchDistance;
        const newZoom = initialPinchZoom * scale;
        zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
       }
      }
     }, {
      passive: false
     }, );
    let panStartViewX = 0;
    let panStartViewY = 0;
    viewport.addEventListener("mousedown", (e) => {
     if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
      return;
     }
     const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
     if (isEmptySpace || canvasState.spacePressed) {
      e.preventDefault();
      canvasState.isPanning = true;
      canvasState.panStartX = e.clientX;
      canvasState.panStartY = e.clientY;
      panStartViewX = canvasState.panX;
      panStartViewY = canvasState.panY;
      viewport.classList.add("panning");
     }
    });
    viewport.addEventListener("touchstart",
     (e) => {
      if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
       return;
      }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      if (isEmptySpace && e.touches.length === 1) {
       e.preventDefault();
       canvasState.isPanning = true;
       canvasState.panStartX = e.touches[0].clientX;
       canvasState.panStartY = e.touches[0].clientY;
       panStartViewX = canvasState.panX;
       panStartViewY = canvasState.panY;
       viewport.classList.add("panning");
      }
     }, {
      passive: false
     }, );
    document.addEventListener("mousemove", (e) => {
     if (!canvasState.isPanning) return;
     const dx = e.clientX - canvasState.panStartX;
     const dy = e.clientY - canvasState.panStartY;
     const rect = viewport.getBoundingClientRect();
     const viewWidth = CANVAS_WIDTH / canvasState.zoom;
     const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
     const canvasDx = (dx / rect.width) * viewWidth;
     const canvasDy = (dy / rect.height) * viewHeight;
     canvasState.panX = panStartViewX - canvasDx;
     canvasState.panY = panStartViewY - canvasDy;
     constrainPan();
     updateViewBox();
    });
    document.addEventListener("touchmove", (e) => {
     if (!canvasState.isPanning || !e.touches[0]) return;
     const dx = e.touches[0].clientX - canvasState.panStartX;
     const dy = e.touches[0].clientY - canvasState.panStartY;
     const rect = viewport.getBoundingClientRect();
     const viewWidth = CANVAS_WIDTH / canvasState.zoom;
     const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
     const canvasDx = (dx / rect.width) * viewWidth;
     const canvasDy = (dy / rect.height) * viewHeight;
     canvasState.panX = panStartViewX - canvasDx;
     canvasState.panY = panStartViewY - canvasDy;
     constrainPan();
     updateViewBox();
    });
    document.addEventListener("mouseup", () => {
     if (canvasState.isPanning) {
      canvasState.isPanning = false;
      viewport.classList.remove("panning");
     }
    });
    document.addEventListener("touchend", () => {
     if (canvasState.isPanning) {
      canvasState.isPanning = false;
      viewport.classList.remove("panning");
     }
    });
    document.addEventListener("keydown", (e) => {
     const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
     if (e.code === "Space" && !e.repeat && !isEditing) {
      e.preventDefault();
      canvasState.spacePressed = true;
      viewport.style.cursor = "grab";
     }
    });
    document.addEventListener("keyup", (e) => {
     if (e.code === "Space") {
      canvasState.spacePressed = false;
      viewport.style.cursor = "";
     }
    });
    document.getElementById("zoom-in-btn").addEventListener("click", () => {
     zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
    });
    document.getElementById("zoom-out-btn").addEventListener("click", () => {
     zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
    });
    document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
    document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
    const minimapContainer = document.getElementById("minimap-container");
    const minimapSvg = document.getElementById("minimap");
    let minimapDragging = false;
    minimapContainer.addEventListener("mousedown", (e) => {
     e.preventDefault();
     minimapDragging = true;
     updatePanFromMinimap(e);
    });
    minimapContainer.addEventListener("touchstart",
     (e) => {
      e.preventDefault();
      minimapDragging = true;
      updatePanFromMinimapTouch(e);
     }, {
      passive: false
     }, );
    document.addEventListener("mousemove", (e) => {
     if (minimapDragging) {
      updatePanFromMinimap(e);
     }
    });
    document.addEventListener("touchmove", (e) => {
     if (minimapDragging && e.touches[0]) {
      updatePanFromMinimapTouch(e);
     }
    });
    document.addEventListener("mouseup", () => {
     minimapDragging = false;
    });
    document.addEventListener("touchend", () => {
     minimapDragging = false;
    });

    function updatePanFromMinimap(e) {
     const rect = minimapContainer.getBoundingClientRect();
     const x = (e.clientX - rect.left) / rect.width;
     const y = (e.clientY - rect.top) / rect.height;
     const viewWidth = CANVAS_WIDTH / canvasState.zoom;
     const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
     canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
     canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
     constrainPan();
     updateViewBox();
    }

    function updatePanFromMinimapTouch(e) {
     const rect = minimapContainer.getBoundingClientRect();
     const touch = e.touches[0];
     const x = (touch.clientX - rect.left) / rect.width;
     const y = (touch.clientY - rect.top) / rect.height;
     const viewWidth = CANVAS_WIDTH / canvasState.zoom;
     const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
     canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
     canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
     constrainPan();
     updateViewBox();
    }
    document.addEventListener("keydown", (e) => {
     if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
     if (
      (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
     } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
     } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      resetView();
     }
    });
    setTimeout(() => {
     fitToContent();
    }, 100);
   })();
   const sizeSlider = document.getElementById("size-slider");
   const sizeValue = document.getElementById("size-value");
   const resetSizeBtn = document.getElementById("reset-size");
   sizeSlider.addEventListener("input", () => {
    const newSize = parseInt(sizeSlider.value, 10);
    sizeValue.textContent = newSize;
    savedSizes[currentNodeId] = newSize;
    const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
    if (nodeGroup) {
     const oldShape = nodeGroup.querySelector(".node-circle");
     if (oldShape) oldShape.remove();
     const newShape = createNodeShape(currentNodeId, newSize);
     nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
										   
     const styles = resolveStylesForNode(currentNodeId);
     if (styles.circleColor) newShape.style.stroke = styles.circleColor;
															
     const label = nodeGroup.querySelector(".node-label");
     const sub = nodeGroup.querySelector(".node-sub");
     if (label) {
      label.setAttribute("y", -newSize * 0.28);
      const labelSize = styles.titleSize || newSize * 0.33;
      label.style.fontSize = labelSize + "px";
     }
     if (sub) {
      sub.setAttribute("y", newSize * 0.4);
      const subSize = styles.subSize || newSize * 0.24;
      sub.style.fontSize = subSize + "px";
     }
    }
   });
   resetSizeBtn.addEventListener("click", () => {
    delete savedSizes[currentNodeId];
    const defaultSize = getDefaultSize();
    sizeSlider.value = defaultSize;
    sizeValue.textContent = defaultSize;
    const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
    if (nodeGroup) {
     const oldShape = nodeGroup.querySelector(".node-circle");
     if (oldShape) oldShape.remove();
     const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
     const newShape = createNodeShape(currentNodeId, defaultSize);
     nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
     const styles = resolveStylesForNode(currentNodeId);
     if (styles.circleColor) newShape.style.stroke = styles.circleColor;
     const label = nodeGroup.querySelector(".node-label");
     const sub = nodeGroup.querySelector(".node-sub");
     if (label) {
      label.setAttribute("y", -defaultSize * 0.28);
      const labelSize = styles.titleSize || defaultSize * 0.33;
      label.style.fontSize = labelSize + "px";
     }
     if (sub) {
      sub.setAttribute("y", defaultSize * 0.4);
      const subSize = styles.subSize || defaultSize * 0.24;
      sub.style.fontSize = subSize + "px";
     }
    }
   });
   const applyStyle = (property, value) => {
    const styleEntry = ensureStyleEntry(currentNodeId);
    const scopeKey = currentStyleScope || "all";
    if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
    styleEntry[scopeKey][property] = value;
    const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
    if (!nodeGroup) return;
    const shapeEl = nodeGroup.querySelector(".node-circle");
    const label = nodeGroup.querySelector(".node-label");
    const sub = nodeGroup.querySelector(".node-sub");
    if (property === "circleColor" && shapeEl) shapeEl.style.stroke = value;
    else if (property === "titleColor" && label) label.style.fill = value;
    else if (property === "titleFont" && label) label.style.fontFamily = value;
    else if (property === "titleSize" && label) label.style.fontSize = value + "px";
    else if (property === "subColor" && sub) sub.style.fill = value;
    else if (property === "subFont" && sub) sub.style.fontFamily = value;
    else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
   };
   document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
   document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
   document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
   document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
   document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
   document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
   document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
   document.getElementById("title-offset-y").addEventListener("input", (e) => {
    applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
    forgeTheTopology();
    if (currentNodeId) claimTheImmortal(currentNodeId);
   });
   document.getElementById("title-offset-x").addEventListener("input", (e) => {
    applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
    forgeTheTopology();
    if (currentNodeId) claimTheImmortal(currentNodeId);
   });
   document.getElementById("sub-offset-y").addEventListener("input", (e) => {
    applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
    forgeTheTopology();
    if (currentNodeId) claimTheImmortal(currentNodeId);
   });
   document.getElementById("sub-offset-x").addEventListener("input", (e) => {
    applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
    forgeTheTopology();
    if (currentNodeId) claimTheImmortal(currentNodeId);
   });
   document.getElementById("reset-styles").addEventListener("click", () => {
    delete savedStyles[currentNodeId];
    forgeTheTopology();
    claimTheImmortal(currentNodeId);
   });
   document.getElementById("style-scope").addEventListener("change", (e) => {
    currentStyleScope = e.target.value || "all";
    claimTheImmortal(currentNodeId);
   });
   document.getElementById("shape-select").addEventListener("change", (e) => {
    const shape = e.target.value || "circle";
    NODE_DATA[currentNodeId].shape = shape;
    const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
    if (!nodeGroup) return;
    const oldShape = nodeGroup.querySelector(".node-circle");
    if (oldShape) oldShape.remove();
    const size = savedSizes[currentNodeId] || getDefaultSize();
    const newShape = createNodeShape(currentNodeId, size);
    nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
   });
   const addNoteBtn = document.getElementById("add-note-btn");
   const noteInput = document.getElementById("new-note-input");
   addNoteBtn.addEventListener("click", () => {
    const newNote = noteInput.value.trim();
    if (newNote && currentNodeId) {
     NODE_DATA[currentNodeId].notes.push(newNote);
     claimTheImmortal(currentNodeId);
     noteInput.value = "";
    }
   });
   noteInput.addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
     addNoteBtn.click();
    }
   });
   document.getElementById("edge-width").addEventListener("input", () => {
    if (!currentEdgeId) return;
    const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
    if (!edge) return;
    const v = parseInt(document.getElementById("edge-width").value, 10);
    if (Number.isNaN(v) || v <= 0) return;
    edge.width = v;
    saveEdgeData();
    const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
    if (el) el.style.strokeWidth = v;
   });
   document.getElementById("edge-color").addEventListener("input", () => {
    if (!currentEdgeId) return;
    const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
    if (!edge) return;
    const color = document.getElementById("edge-color").value;
    edge.color = color;
    saveEdgeData();
    const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
    if (el) el.style.stroke = color;
    forgeTheLegend();
   });
   document.getElementById("edge-direction").addEventListener("change", () => {
    if (!currentEdgeId) return;
    const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
    if (!edge) return;
    edge.direction = document.getElementById("edge-direction").value;
    saveEdgeData();
    forgeTheTopology();
    selectTheConnection(currentEdgeId);
   });
   document.getElementById("edge-line-style").addEventListener("change", () => {
    if (!currentEdgeId) return;
    const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
    if (!edge) return;
    edge.lineStyle = document.getElementById("edge-line-style").value;
    saveEdgeData();
    forgeTheTopology();
    selectTheConnection(currentEdgeId);
   });
   const addEdgeNoteBtn = document.getElementById("add-edge-note");
   const newEdgeNoteInput = document.getElementById("new-edge-note");
   addEdgeNoteBtn.addEventListener("click", () => {
    const txt = newEdgeNoteInput.value.trim();
    if (!txt || !currentEdgeId) return;
    const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
    if (!edge) return;
    edge.notes.push(txt);
    saveEdgeData();
    newEdgeNoteInput.value = "";
    selectTheConnection(currentEdgeId);
   });
   newEdgeNoteInput.addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
     addEdgeNoteBtn.click();
    }
   });
   document.getElementById("delete-edge").addEventListener("click", () => {
    if (!currentEdgeId) return;
    challengeTheImmortal("Are you sure you want to delete this line?",
     () => {
      EDGE_DATA.list = EDGE_DATA.list.filter(
       (e) => e.id !== currentEdgeId, );
      saveEdgeData();
      currentEdgeId = null;
      forgeTheTopology();
      const availableNodes = Object.keys(NODE_DATA);
      if (availableNodes.length > 0) {
       claimTheImmortal(availableNodes[0]);
      } else {
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("topology-toolbar", ).style.display = "none";
      }
     }, );
   });
   document.getElementById("add-line-btn").addEventListener("click", () => {
    if (!currentNodeId) return;
    const select = document.getElementById("add-line-select");
    const directionSelect = document.getElementById("add-line-direction");
    const colorInput = document.getElementById("add-line-color");
    const targetId = select.value;
    if (!targetId || targetId === currentNodeId) return;
    const direction = directionSelect.value || "none";
    const lineColor = colorInput.value || "#475569";
    const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
    const newEdge = {
     id: newId,
     from: currentNodeId,
     to: targetId,
     width: 4,
     color: lineColor,
     direction: direction,
     type: "main",
     notes: [],
    };
    EDGE_DATA.list.push(newEdge);
    saveEdgeData();
    forgeTheTopology();
    claimTheImmortal(currentNodeId);
   });
   let freeDrawMode = false;
   let freeDrawPoints = [];
   let freeDrawPolylineEl = null;
   let freeDrawPointEls = [];
   const drawToggleBtn = document.getElementById("draw-toggle");
   const drawUndoBtn = document.getElementById("draw-undo");
   const drawColorInput = document.getElementById("draw-color");
   const drawStyleSelect = document.getElementById("draw-style");
   const drawArrowSelect = document.getElementById("draw-arrow");
   const svgMap = document.getElementById("map");

   function updateFreeDrawGraphics() {
    const ns = "http://www.w3.org/2000/svg";
    const svg = svgMap;
    if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
     freeDrawPolylineEl = document.createElementNS(ns, "polyline");
     freeDrawPolylineEl.classList.add("edge", "free-preview");
     freeDrawPolylineEl.setAttribute("fill", "none");
     svg.appendChild(freeDrawPolylineEl);
    }
    if (freeDrawPolylineEl) {
     if (freeDrawPoints.length === 0) {
      freeDrawPolylineEl.remove();
      freeDrawPolylineEl = null;
     } else {
      const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
      freeDrawPolylineEl.setAttribute("points", ptsStr);
      freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
      freeDrawPolylineEl.style.strokeWidth = 3;
      const lineStyle = drawStyleSelect.value || "solid";
      if (lineStyle === "dashed") {
       freeDrawPolylineEl.style.strokeDasharray = "10,5";
      } else if (lineStyle === "dotted") {
       freeDrawPolylineEl.style.strokeDasharray = "2,4";
      } else {
       freeDrawPolylineEl.style.strokeDasharray = "none";
      }
     }
    }
    freeDrawPointEls.forEach((el) => el.remove());
    freeDrawPointEls = [];
    freeDrawPoints.forEach((p, idx) => {
     const c = document.createElementNS(ns, "circle");
     c.classList.add("free-point");
     c.setAttribute("cx", p.x);
     c.setAttribute("cy", p.y);
     c.setAttribute("r", 5);
     c.dataset.index = String(idx);
     c.addEventListener("mousedown", (e) => {
      if (!freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const svgEl = svgMap;
      const moveHandler = (ev) => {
       if (!dragging) return;
       const pt = svgEl.createSVGPoint();
       pt.x = ev.clientX;
       pt.y = ev.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
       const i = parseInt(c.dataset.index, 10);
       if (Number.isNaN(i) || !freeDrawPoints[i]) return;
       freeDrawPoints[i].x = svgP.x;
       freeDrawPoints[i].y = svgP.y;
       updateFreeDrawGraphics();
      };
      const upHandler = () => {
       dragging = false;
       document.removeEventListener("mousemove", moveHandler);
       document.removeEventListener("mouseup", upHandler);
      };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
     });
     c.addEventListener("touchstart",
      (e) => {
       if (!freeDrawMode) return;
       e.preventDefault();
       e.stopPropagation();
       let dragging = true;
       const svgEl = svgMap;
       const touchMoveHandler = (ev) => {
        if (!dragging || !ev.touches[0]) return;
        const pt = svgEl.createSVGPoint();
        pt.x = ev.touches[0].clientX;
        pt.y = ev.touches[0].clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
        const i = parseInt(c.dataset.index, 10);
        if (Number.isNaN(i) || !freeDrawPoints[i]) return;
        freeDrawPoints[i].x = svgP.x;
        freeDrawPoints[i].y = svgP.y;
        updateFreeDrawGraphics();
       };
       const touchUpHandler = () => {
        dragging = false;
        document.removeEventListener("touchmove", touchMoveHandler, );
        document.removeEventListener("touchend", touchUpHandler, );
       };
       document.addEventListener("touchmove", touchMoveHandler);
       document.addEventListener("touchend", touchUpHandler);
      }, {
       passive: false
      }, );
     svg.appendChild(c);
     freeDrawPointEls.push(c);
    });
    drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
   }

   function addFreeDrawPoint(x, y) {
    freeDrawPoints.push({
     x,
     y
    });
    updateFreeDrawGraphics();
   }

   function startFreeDraw() {
    freeDrawMode = true;
    freeDrawPoints = [];
    if (freeDrawPolylineEl) {
     freeDrawPolylineEl.remove();
     freeDrawPolylineEl = null;
    }
    freeDrawPointEls.forEach((el) => el.remove());
    freeDrawPointEls = [];
    svgMap.style.cursor = "crosshair";
    drawToggleBtn.textContent = "Done";
    drawUndoBtn.style.display = "none";
   }

   function finishFreeDraw() {
    freeDrawMode = false;
    svgMap.style.cursor = "";
    drawToggleBtn.textContent = "‚úèÔ∏è";
    if (freeDrawPoints.length >= 2) {
     const color = drawColorInput.value || "#475569";
     const lineStyle = drawStyleSelect.value || "solid";
     const arrowDir = drawArrowSelect.value || "none";
     const newId = "custom-" + Date.now();
     const pointsCopy = freeDrawPoints.map((p) => ({
      x: p.x,
      y: p.y,
     }));
     EDGE_DATA.list.push({
      id: newId,
      type: "custom",
      color,
      width: 4,
      lineStyle: lineStyle,
      direction: arrowDir,
      points: pointsCopy,
      notes: [],
     });
     saveEdgeData();
     freeDrawPoints = [];
     if (freeDrawPolylineEl) {
      freeDrawPolylineEl.remove();
      freeDrawPolylineEl = null;
     }
     freeDrawPointEls.forEach((el) => el.remove());
     freeDrawPointEls = [];
     forgeTheTopology();
     selectTheConnection(newId);
    } else {
     freeDrawPoints = [];
     if (freeDrawPolylineEl) {
      freeDrawPolylineEl.remove();
      freeDrawPolylineEl = null;
     }
     freeDrawPointEls.forEach((el) => el.remove());
     freeDrawPointEls = [];
     forgeTheLegend();
    }
    drawUndoBtn.style.display = "none";
   }
   drawToggleBtn.addEventListener("click", () => {
    if (freeDrawMode) {
     finishFreeDraw();
    } else {
     startFreeDraw();
    }
   });
   drawUndoBtn.addEventListener("click", () => {
    if (!freeDrawMode || !freeDrawPoints.length) return;
    freeDrawPoints.pop();
    updateFreeDrawGraphics();
   });
   const drawToolbar = document.getElementById("draw-toolbar");
   drawToolbar.addEventListener("mousedown", (e) => {
    e.stopPropagation();
   });
   drawToolbar.addEventListener("click", (e) => {
    if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
     e.stopPropagation();
    }
   });
   drawStyleSelect.addEventListener("change", () => {
    if (freeDrawMode) {
     updateFreeDrawGraphics();
    }
   });
   drawArrowSelect.addEventListener("change", () => {
    if (freeDrawMode) {
     updateFreeDrawGraphics();
    }
   });
   drawColorInput.addEventListener("input", () => {
    if (freeDrawMode) {
     updateFreeDrawGraphics();
    }
   });
   drawStyleSelect.addEventListener("mousedown", (e) => {
    e.stopPropagation();
   });
   drawStyleSelect.addEventListener("click", (e) => {
    e.stopPropagation();
   });
   drawArrowSelect.addEventListener("mousedown", (e) => {
    e.stopPropagation();
   });
   drawArrowSelect.addEventListener("click", (e) => {
    e.stopPropagation();
   });
   drawColorInput.addEventListener("mousedown", (e) => {
    e.stopPropagation();
   });
   drawColorInput.addEventListener("click", (e) => {
    e.stopPropagation();
   });
   svgMap.addEventListener("click", (e) => {
    if (!freeDrawMode) return;
    if (e.button !== 0) return;
    const target = e.target;
    if (target && target.classList && target.classList.contains("free-point")) return;
    const svgEl = svgMap;
    const pt = svgEl.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
    addFreeDrawPoint(svgP.x, svgP.y);
   });
   svgMap.addEventListener("touchend",
    (e) => {
     if (!freeDrawMode) return;
     const target = e.target;
     if (target && target.classList && target.classList.contains("free-point")) return;
     if (e.changedTouches && e.changedTouches[0]) {
      e.preventDefault();
      const svgEl = svgMap;
      const pt = svgEl.createSVGPoint();
      pt.x = e.changedTouches[0].clientX;
      pt.y = e.changedTouches[0].clientY;
      const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
      addFreeDrawPoint(svgP.x, svgP.y);
     }
    }, {
     passive: false
    }, );
   const settingsBtn = document.getElementById("settings-btn");
   const settingsModal = document.getElementById("settings-modal");
   const settingsClose = document.getElementById("settings-close");
   settingsBtn.addEventListener("click", () => {
    document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
    document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
    document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
    document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
    document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
    document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
    document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
    document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
    document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
    settingsModal.classList.add("active");
   });
   settingsClose.addEventListener("click", () => {
    settingsModal.classList.remove("active");
   });
   settingsModal.addEventListener("click", (e) => {
    if (e.target === settingsModal) {
     settingsModal.classList.remove("active");
    }
   });
   document.getElementById("page-bg-color").addEventListener("input", (e) => {
    PAGE_STATE.background = e.target.value;
    wieldThePower();
   });
   document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
    PAGE_STATE.topbarBg = e.target.value;
    wieldThePower();
   });
   document.getElementById("topbar-border-color").addEventListener("input", (e) => {
    PAGE_STATE.topbarBorder = e.target.value;
    wieldThePower();
   });
   document.getElementById("panel-color").addEventListener("input", (e) => {
    PAGE_STATE.panel = e.target.value;
    wieldThePower();
   });
   document.getElementById("panel-alt-color").addEventListener("input", (e) => {
    PAGE_STATE.panelAlt = e.target.value;
    wieldThePower();
   });
   document.getElementById("accent-color").addEventListener("input", (e) => {
    PAGE_STATE.accent = e.target.value;
    wieldThePower();
   });
   document.getElementById("danger-color").addEventListener("input", (e) => {
    PAGE_STATE.danger = e.target.value;
    wieldThePower();
   });
   document.getElementById("text-main-color").addEventListener("input", (e) => {
    PAGE_STATE.textMain = e.target.value;
    wieldThePower();
   });
   document.getElementById("text-soft-color").addEventListener("input", (e) => {
    PAGE_STATE.textSoft = e.target.value;
    wieldThePower();
   });
   document.getElementById("topbar-height").addEventListener("input", (e) => {
    PAGE_STATE.topbarHeight = parseInt(e.target.value, 10);
    document.getElementById("topbar-height-val").textContent = PAGE_STATE.topbarHeight + "px";
    wieldThePower();
   });
   document.getElementById("sidebar-width").addEventListener("input", (e) => {
    PAGE_STATE.sidebarWidth = parseInt(e.target.value, 10);
    document.getElementById("sidebar-width-val").textContent = PAGE_STATE.sidebarWidth + "px";
    wieldThePower();
   });
   document.getElementById("mobile-footer-height").addEventListener("input", (e) => {
    PAGE_STATE.mobileFooterHeight = parseInt(e.target.value, 10);
    document.getElementById("mobile-footer-height-val").textContent = PAGE_STATE.mobileFooterHeight + "%";
    wieldThePower();
   });
   document.getElementById("export-data-btn").addEventListener("click", () => {
    const data = captureTheQuickening();
    const jsonStr = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonStr], {
     type: "application/json"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
    const timestamp = new Date().toISOString().split("T")[0];
    a.download = `${safeTitle}-data-${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
   });
   document.getElementById("import-data-btn").addEventListener("click", () => {
    document.getElementById("import-data-file").click();
   });
   document.getElementById("import-data-file").addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    try {
     const text = await file.text();
     const data = JSON.parse(text);
     if (!data.nodeData || !data.edgeData) {
      alert("Invalid data file. Missing required fields.");
      return;
     }
     const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n\nContinue?`;
     if (!confirm(confirmMsg)) {
      e.target.value = "";
      return;
     }
     NODE_DATA = data.nodeData || {};
     EDGE_DATA = data.edgeData || {
      list: []
     };
     EDGE_LEGEND = data.edgeLegend || {};
     savedPositions = data.nodePositions || {};
     savedSizes = data.nodeSizes || {};
     savedStyles = data.nodeStyles || {};
     if (data.page) {
      PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
      wieldThePower();
     }
     if (data.canvas) {
      canvasState.zoom = data.canvas.zoom || 1;
      canvasState.panX = data.canvas.panX || 0;
      canvasState.panY = data.canvas.panY || 0;
     }
     if (data.page?.title) {
      document.title = data.page.title;
      document.querySelector(".editable-page-title", ).textContent = data.page.title;
     }
     forgeTheTopology();
     forgeTheLegend();
     updateViewBox();
     const nodeIds = Object.keys(NODE_DATA);
     if (nodeIds.length > 0) {
      claimTheImmortal(nodeIds[0]);
     } else {
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("topology-toolbar").style.display = "none";
     }
     alert("Data imported successfully!");
     e.target.value = "";
    } catch (err) {
     console.error("Import error:", err);
     alert(`Failed to import data: ${err.message}`);
     e.target.value = "";
    }
   });
   const saveHelpBtn = document.getElementById("save-help-btn");
   const saveInfoModal = document.getElementById("save-info-modal");
   const saveInfoClose = document.getElementById("save-info-close");
   saveHelpBtn.addEventListener("click", () => {
    saveInfoModal.classList.add("active");
   });
   saveInfoClose.addEventListener("click", () => {
    saveInfoModal.classList.remove("active");
   });
   saveInfoModal.addEventListener("click", (e) => {
    if (e.target === saveInfoModal) {
     saveInfoModal.classList.remove("active");
    }
   });
   async function deriveKey(password, salt) {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey("raw", encoder.encode(password), "PBKDF2", false,
     ["deriveKey"], );
    return crypto.subtle.deriveKey({
      name: "PBKDF2",
      salt: salt,
      iterations: 100000,
      hash: "SHA-256",
     }, keyMaterial, {
      name: "AES-GCM",
      length: 256
     }, false,
     ["encrypt", "decrypt"], );
   }
   async function encryptData(data, password) {
    const encoder = new TextEncoder();
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKey(password, salt);
    const encrypted = await crypto.subtle.encrypt({
     name: "AES-GCM",
     iv: iv
    }, key, encoder.encode(data), );
    const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength, );
    result.set(salt, 0);
    result.set(iv, salt.length);
    result.set(new Uint8Array(encrypted), salt.length + iv.length);
    return "ENCRYPTED:" + btoa(String.fromCharCode(...result));
   }
   async function decryptData(encryptedData, password) {
    const base64Data = encryptedData.replace("ENCRYPTED:", "");
    const data = Uint8Array.from(atob(base64Data), (c) => c.charCodeAt(0), );
    const salt = data.slice(0, 16);
    const iv = data.slice(16, 28);
    const encrypted = data.slice(28);
    const key = await deriveKey(password, salt);
    const decrypted = await crypto.subtle.decrypt({
     name: "AES-GCM",
     iv: iv
    }, key, encrypted, );
    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
   }

   function isEncrypted(data) {
    return typeof data === "string" && data.startsWith("ENCRYPTED:");
   }

   function captureTheQuickening() {
    return {
     nodeData: NODE_DATA,
     edgeData: EDGE_DATA,
     edgeLegend: EDGE_LEGEND,
     nodePositions: savedPositions,
     nodeSizes: savedSizes,
     nodeStyles: savedStyles,
     iconCache: IconLibrary.iconCache,
     page: PAGE_STATE,
     canvas: {
      zoom: canvasState.zoom,
      panX: canvasState.panX,
      panY: canvasState.panY,
     },
    };
   }

   function assembleTheImmortalForm() {
    const clone = document.documentElement.cloneNode(true);
    const nodeScript = clone.querySelector("#nodes-json");
    if (nodeScript) {
     nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
    }
    let stateScript = clone.querySelector("#topology-state");
    if (!stateScript) {
     stateScript = document.createElement("script");
     stateScript.id = "topology-state";
     stateScript.type = "application/json";
     const body = clone.querySelector("body") || clone;
     body.appendChild(stateScript);
    }
    stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
    return " < !DOCTYPE html > \n " + clone.outerHTML;
   }
   async function becomeImmortal() {
    const encryptEnabled = document.getElementById("encrypt-toggle").checked;
    let stateData = JSON.stringify(captureTheQuickening(), null, 2);
    if (encryptEnabled) {
     const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
     if (!password) {
      alert("Encryption cancelled. File not saved.");
      return;
     }
     const confirmPassword = prompt("Confirm your password:");
     if (password !== confirmPassword) {
      alert("Passwords do not match. File not saved.");
      return;
     }
     try {
      stateData = await encryptData(stateData, password);
     } catch (e) {
      alert("Encryption failed: " + e.message);
      return;
     }
    }
    const clone = document.documentElement.cloneNode(true);
    const nodeScript = clone.querySelector("#nodes-json");
    if (nodeScript) {
     if (encryptEnabled) {
      nodeScript.textContent = JSON.stringify({}, null, 2);
     } else {
      nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
     }
    }
    let stateScript = clone.querySelector("#topology-state");
    if (!stateScript) {
     stateScript = document.createElement("script");
     stateScript.id = "topology-state";
     stateScript.type = "application/json";
     const body = clone.querySelector("body") || clone;
     body.appendChild(stateScript);
    }
    stateScript.textContent = stateData;
    const html = " < !DOCTYPE html > \n " + clone.outerHTML;
    const blob = new Blob([html], {
     type: "text/html"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
    a.download = safeTitle + ".html";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
   }
   document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
   const addNodeBtn = document.getElementById("add-node-btn");
   const addNodeModal = document.getElementById("add-node-modal");
   const addNodeCancel = document.getElementById("add-node-cancel");
   const addNodeSave = document.getElementById("add-node-save");
   addNodeBtn.addEventListener("click", () => {
    document.getElementById("new-node-name").value = "";
    document.getElementById("new-node-ip").value = "";
    document.getElementById("new-node-tags").value = "";
    document.getElementById("new-node-shape").value = "circle";
    addNodeModal.classList.add("active");
    document.getElementById("new-node-name").focus();
   });
   addNodeCancel.addEventListener("click", () => {
    addNodeModal.classList.remove("active");
   });
   addNodeModal.addEventListener("click", (e) => {
    if (e.target === addNodeModal) {
     addNodeModal.classList.remove("active");
    }
   });
   addNodeSave.addEventListener("click", () => {
    const name = document.getElementById("new-node-name").value.trim();
    const ip = document.getElementById("new-node-ip").value.trim();
    const tagsStr = document.getElementById("new-node-tags").value.trim();
    const shape = document.getElementById("new-node-shape").value;
    if (!name) {
     alert("Please enter a node name.");
     return;
    }
    const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
    let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
    if (!baseId) baseId = "node";
    let nodeId = baseId;
    let counter = 1;
    while (NODE_DATA[nodeId]) {
     nodeId = baseId + "-" + counter;
     counter++;
    }
    NODE_DATA[nodeId] = {
     shape: shape || "circle",
     name: name,
     ip: ip || "0.0.0.0",
     role: "",
     tags: tags,
     notes: [],
    };
    
    if (selectedNodeIconData) {
     if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
     if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
     savedStyles[nodeId]['all'].icon = {
      library: selectedNodeIconData.library,
      name: selectedNodeIconData.name
     };
     selectedNodeIconData = null;
     document.getElementById('selected-node-icon').style.display = 'none';
    }
    
    const centerX = CANVAS_WIDTH / 2;
    const centerY = CANVAS_HEIGHT / 2;
    savedPositions[nodeId] = {
     x: centerX,
     y: centerY
    };
    addNodeModal.classList.remove("active");
    forgeTheTopology();
    claimTheImmortal(nodeId);
   });
   ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
    (inputId) => {
     document.getElementById(inputId).addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
       addNodeSave.click();
      }
     });
    }, );

   let selectedNodeIconData = null;
   
   document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
    openIconPicker((iconData) => {
     selectedNodeIconData = iconData;
     const preview = document.getElementById('selected-node-icon-preview');
     const container = document.getElementById('selected-node-icon');
     
     const parser = new DOMParser();
     const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
     const svgEl = doc.querySelector('svg');
     
     preview.innerHTML = '';
     if (svgEl) {
      preview.appendChild(svgEl.cloneNode(true));
     }
     const nameSpan = document.createElement('span');
     nameSpan.textContent = iconData.name;
     preview.appendChild(nameSpan);
     
     container.style.display = 'block';
    });
   });
   
   document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
    if (!currentNodeId) return;
    
    openIconPicker((iconData) => {
     if (!NODE_DATA[currentNodeId].tags) {
      NODE_DATA[currentNodeId].tags = [];
     }
     NODE_DATA[currentNodeId].tags.push({
      type: 'icon',
      library: iconData.library,
      name: iconData.name
     });
     forgeTheTopology();
     claimTheImmortal(currentNodeId);
    });
   });
   
   document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
    if (!currentNodeId) return;
    
    openIconPicker((iconData) => {
     if (!savedStyles[currentNodeId]) {
      savedStyles[currentNodeId] = {};
     }
     if (!savedStyles[currentNodeId][currentStyleScope]) {
      savedStyles[currentNodeId][currentStyleScope] = {};
     }
     savedStyles[currentNodeId][currentStyleScope].icon = {
      library: iconData.library,
      name: iconData.name
     };
     forgeTheTopology();
    });
   });
   
   document.getElementById('add-tag-btn').addEventListener('click', () => {
    if (!currentNodeId) return;
    const input = document.getElementById('new-tag-input');
    const tagText = input.value.trim();
    if (!tagText) return;
    
    if (!NODE_DATA[currentNodeId].tags) {
     NODE_DATA[currentNodeId].tags = [];
    }
    NODE_DATA[currentNodeId].tags.push(tagText);
    input.value = '';
    forgeTheTopology();
    claimTheImmortal(currentNodeId);
   });

   const clearAllBtn = document.getElementById("clear-all-btn");
   const clearAllModal = document.getElementById("clear-all-modal");
   const clearAllCancel = document.getElementById("clear-all-cancel");
   const clearAllConfirm = document.getElementById("clear-all-confirm");
   clearAllBtn.addEventListener("click", () => {
    clearAllModal.classList.add("active");
   });
   clearAllCancel.addEventListener("click", () => {
    clearAllModal.classList.remove("active");
   });
   clearAllModal.addEventListener("click", (e) => {
    if (e.target === clearAllModal) {
     clearAllModal.classList.remove("active");
    }
   });
   clearAllConfirm.addEventListener("click", () => {
    NODE_DATA = {};
    EDGE_DATA = {
     list: []
    };
    EDGE_LEGEND = {};
    savedPositions = {};
    savedSizes = {};
    savedStyles = {};
    clearAllModal.classList.remove("active");
    forgeTheTopology();
    document.getElementById("node-panel").style.display = "none";
    document.getElementById("edge-panel").style.display = "none";
    document.getElementById("topology-toolbar").style.display = "none";
    currentNodeId = null;
    currentEdgeId = null;
   });
   (function addDeleteNodeButton() {
    const nodePanel = document.getElementById("node-panel");
    if (!nodePanel) return;
    if (document.getElementById("delete-node-btn")) return;
    const deleteBtn = document.createElement("button");
    deleteBtn.id = "delete-node-btn";
    deleteBtn.textContent = "Delete Node";
    deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
    deleteBtn.addEventListener("click", () => {
     if (!currentNodeId) return;
     challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`,
      () => {
       EDGE_DATA.list = EDGE_DATA.list.filter(
        (e) => e.from !== currentNodeId && e.to !== currentNodeId, );
       delete NODE_DATA[currentNodeId];
       delete savedPositions[currentNodeId];
       delete savedSizes[currentNodeId];
       delete savedStyles[currentNodeId];
       currentNodeId = null;
       currentEdgeId = null;
       forgeTheTopology();
       const remainingNodes = Object.keys(NODE_DATA);
       if (remainingNodes.length > 0) {
        claimTheImmortal(remainingNodes[0]);
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("topology-toolbar", ).style.display = "none";
       }
      }, );
    });
    nodePanel.appendChild(deleteBtn);
   })();

   function screenshotCanvas() {
    const svg = document.getElementById("map");
    const svgClone = svg.cloneNode(true);
    const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
    const [x, y, width, height] = viewBox;
    svgClone.setAttribute("width", width);
    svgClone.setAttribute("height", height);
    svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
    const wrapper = document.createElement("div");
    wrapper.style.position = "absolute";
    wrapper.style.left = "-9999px";
    wrapper.appendChild(svgClone);
    document.body.appendChild(wrapper);

    function inlineStyles(original, clone) {
     const elements = original.querySelectorAll("*");
     const clonedElements = clone.querySelectorAll("*");
     const rootStyles = getComputedStyle(document.documentElement);
     const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
     const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
     bgRect.setAttribute("x", x);
     bgRect.setAttribute("y", y);
     bgRect.setAttribute("width", width);
     bgRect.setAttribute("height", height);
     bgRect.setAttribute("fill", bgColor);
     clone.insertBefore(bgRect, clone.firstChild);
     elements.forEach((el, index) => {
      const clonedEl = clonedElements[index];
      if (!clonedEl) return;
      const computedStyle = getComputedStyle(el);
      const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
      svgProps.forEach((prop) => {
       const value = computedStyle.getPropertyValue(prop);
       if (value && value !== "none" && value !== "normal") {
        clonedEl.style[prop] = value;
       }
      });
      clonedEl.removeAttribute("class");
     });
    }
    inlineStyles(svg, svgClone);
    const svgData = new XMLSerializer().serializeToString(svgClone);
    document.body.removeChild(wrapper);
    const svgBlob = new Blob([svgData], {
     type: "image/svg+xml;charset=utf-8",
    });
    const url = URL.createObjectURL(svgBlob);
    const img = new Image();
    img.onload = function() {
     const canvas = document.createElement("canvas");
     canvas.width = width;
     canvas.height = height;
     const ctx = canvas.getContext("2d");
     ctx.drawImage(img, 0, 0);
     canvas.toBlob(function(blob) {
      const link = document.createElement("a");
      const timestamp = new Date().toISOString().slice(0, 10);
      link.download = `topology-${timestamp}.png`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(url);
      URL.revokeObjectURL(link.href);
     }, "image/png");
    };
    img.onerror = function() {
     console.error("Failed to load SVG image");
     alert("Screenshot failed. Please try again.");
     URL.revokeObjectURL(url);
    };
    img.src = url;
   }

   function exportCanvasSVG() {
    const svg = document.getElementById("map");
    const svgClone = svg.cloneNode(true);
    const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
    const [x, y, width, height] = viewBox;
    svgClone.setAttribute("width", width);
    svgClone.setAttribute("height", height);
    const rootStyles = getComputedStyle(document.documentElement);
    const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
    const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
    bgRect.setAttribute("x", x);
    bgRect.setAttribute("y", y);
    bgRect.setAttribute("width", width);
    bgRect.setAttribute("height", height);
    bgRect.setAttribute("fill", bgColor);
    svgClone.insertBefore(bgRect, svgClone.firstChild);
    const wrapper = document.createElement("div");
    wrapper.style.position = "absolute";
    wrapper.style.left = "-9999px";
    wrapper.appendChild(svgClone);
    document.body.appendChild(wrapper);
    const elements = svg.querySelectorAll("*");
    const clonedElements = svgClone.querySelectorAll("*");
    elements.forEach((el, index) => {
     const clonedEl = clonedElements[index];
     if (!clonedEl) return;
     const computedStyle = getComputedStyle(el);
     const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
     svgProps.forEach((prop) => {
      const value = computedStyle.getPropertyValue(prop);
      if (value && value !== "none" && value !== "normal") {
       clonedEl.setAttribute(prop, value);
      }
     });
     clonedEl.removeAttribute("class");
    });
    const svgData = new XMLSerializer().serializeToString(svgClone);
    document.body.removeChild(wrapper);
    const blob = new Blob([svgData], {
     type: "image/svg+xml;charset=utf-8",
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    const timestamp = new Date().toISOString().slice(0, 10);
    link.download = `topology-${timestamp}.svg`;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
   }
  </script>
 </body>
</html>